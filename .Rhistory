hydroweight_attribute_test_numeric <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
return(test_numericraster)
}
hydroweight_test
length(hydroweight_attribute_test_numeric) # 7 distance-weighted rasters
hydroweight_attribute_test_numeric
vignette("hydroweight")
library(dplyr)
library(foreach)
library(hydroweight)
library(raster)
library(rgeos)
library(sf)
library(sp)
library(viridis)
library(whitebox)
devtools::load_all()
## Import toy_dem from whitebox package
toy_file <- system.file("extdata", "DEM.tif", package="whitebox")
toy_dem <- raster::raster(toy_file, values  = TRUE)
raster::crs(toy_dem)<-CRS("+init=epsg:3161") # arbitrary
## Generate hydroweight_output dir
hydroweight_dir <- tempdir()
## Write toy_dem and run some processing through whitebox
raster::writeRaster(toy_dem,
file.path(hydroweight_dir, "toy_dem.tif"), overwrite = T)
## Breach depressions to ensure continuous flow
wbt_breach_depressions(file.path(hydroweight_dir, "toy_dem.tif"),
file.path(hydroweight_dir, "toy_dem_breached.tif"))
## Generate d8 flow pointer
wbt_d8_pointer(dem = file.path(hydroweight_dir, "toy_dem_breached.tif"),
output = file.path(hydroweight_dir, "toy_dem_breached_d8.tif"))
## Generate d-8 flow accumulation in units of cells
wbt_d8_flow_accumulation(input = file.path(hydroweight_dir, "toy_dem_breached.tif"),
output = file.path(hydroweight_dir, "toy_dem_breached_accum.tif"),
out_type = "cells")
## Generate streams with a stream initiation threshold of 2000 cells
wbt_extract_streams(file.path(hydroweight_dir, "toy_dem_breached_accum.tif"),
file.path(hydroweight_dir, "toy_dem_streams.tif"),
threshold = 2000)
## For hydroweight, there are target_O and target_S
## target_O is a target point/area for calculating distances
## target_S is a stream/waterbody target for calculating distances
## Generate target_0, tg_O
tg_O <- toy_dem<220
tg_O[tg_O@data@values != 1] <- NA
tg_O <- raster::rasterToPolygons(tg_O, dissolve = TRUE)
tg_O <- sf::st_as_sf(tg_O)
## Generate target_S, tg_S
tg_S <- raster::raster(file.path(hydroweight_dir, "toy_dem_streams.tif"))
plot(toy_dem, legend = TRUE, col=viridis(10), main = "Toy DEM")
plot(tg_O, col="red", add = T, legend = FALSE)
plot(tg_S, col="blue", add = T, legend = FALSE)
legend("bottom", legend = c("target_O = tg_O", "target_S = tg_S"), fill = c("red", "blue"), horiz = TRUE, bty = "n" )
myinv <- function(x){ (x * 0.001 + 1)^-1 }
## Run hydroweight
hydroweight_test <- hydroweight::hydroweight(
hydroweight_dir = hydroweight_dir,
target_O = tg_O,
target_S = tg_S,
OS_combine = TRUE,
clip_region = 8000,
dem = "toy_dem_breached.tif",
dem_crs = crs(toy_dem),
flow_accum = "toy_dem_breached_accum.tif",
weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO",
"EucS", "FLS", "HAFLS"),
inv_function = myinv,
uid = "1"
)
length(hydroweight_test) ## 1 set of targets and 7 distance-weighted rasters
## Plot different weighting schemes; Purple --> yellow == low --> high weight
par(mfrow=c(2,4), mar=c(1,1,1,1), oma = c(0,0,0,0))
layout(matrix(c(1, 2, 3, 4,
1, 5, 6, 7), nrow = 2, byrow = TRUE))
plot(hydroweight_test[[1]], main=names(hydroweight_test)[1], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[2]], main=names(hydroweight_test)[2], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[3]], main=names(hydroweight_test)[3], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(log(hydroweight_test[[4]]), main=names(hydroweight_test)[4], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot.new()
plot(hydroweight_test[[5]], main=names(hydroweight_test)[5], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[6]], main=names(hydroweight_test)[6], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(log(hydroweight_test[[7]]), main=names(hydroweight_test)[7], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
## Ignoring target_O
hydroweight_test_no_O <- hydroweight::hydroweight(
hydroweight_dir = hydroweight_dir,
target_S = tg_S,
clip_region = 8000,
dem = "toy_dem_breached.tif",
dem_crs = crs(toy_dem),
flow_accum = "toy_dem_breached_accum.tif",
weighting_scheme = c("EucS", "FLS", "HAFLS"),
inv_function = myinv,
uid = "1"
)
length(hydroweight_test_no_O) ## 1 stream target and 3 distance weightings
## Ignoring target_S
hydroweight_test_no_S <- hydroweight::hydroweight(
hydroweight_dir = hydroweight_dir,
target_O = tg_O,
clip_region = 8000,
dem = "toy_dem_breached.tif",
dem_crs = crs(toy_dem),
flow_accum = "toy_dem_breached_accum.tif",
weighting_scheme = c("EucO", "FLO", "HAFLO"),
inv_function = myinv,
uid = "1"
)
length(hydroweight_test_no_S) ## 1 area target and 3 distance weightings
tg_O$id <- 1
tg_O_x5 <- list(tg_O, tg_O, tg_O, tg_O, tg_O)
tg_O_x5 <- do.call(dplyr::bind_rows, tg_O_x5)
tg_O_x5$id <- seq(1:5)
## Use foreach() but could use lapply() as well.
hydroweight_test_x5 <- foreach(x = 1:5, .errorhandling = "pass") %do% {
message("Running hydroweight for site ", x, " at ", Sys.time())
hydroweight_test <- hydroweight::hydroweight(
hydroweight_dir = hydroweight_dir,
target_O = tg_O_x5[x,],                      ### the important piece to change
target_S = tg_S,
OS_combine = TRUE,
clip_region = 8000,
dem = "toy_dem_breached.tif",
dem_crs = crs(toy_dem),
flow_accum = "toy_dem_breached_accum.tif",
weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO",
"EucS", "FLS", "HAFLS"),
inv_function = myinv,
uid = tg_O_x5$id[x]                          ### the important piece to change
)
return(hydroweight_test)
}
length(hydroweight_test_x5) # 5 sites
length(hydroweight_test_x5[[1]]) # 7 distance-weighted rasters for each site
hydroweight_test_x5[[1]][[2]] # site 1, distance-weighted raster 1
hydroweight_test_x5[[2]][[3]] # site 2, distance-weighted raster 2
## Loading up data after if didn't assign as an object while running
hydroweight_dir_files <- list.files(hydroweight_dir, full.names = TRUE)
hydroweight_test_x5 <- hydroweight_dir_files[grep("_inv_distances.rds", hydroweight_dir_files)]
hydroweight_test_x5 <- lapply(hydroweight_test_x5, function(x) { readRDS(x) })
tg_O_r <- toy_dem<220
tg_O_r[tg_O_r@data@values != 1] <- NA
writeRaster(tg_O_r, file.path(hydroweight_dir, "tg_O_r.tif"), overwrite = TRUE)
wbt_watershed(
d8_pntr = file.path(hydroweight_dir, "toy_dem_breached_d8.tif"),
pour_pts = file.path(hydroweight_dir, "tg_O_r.tif"),
output = file.path(hydroweight_dir, "tg_O_r_catchment.tif"))
tg_O_catchment <- raster(file.path(hydroweight_dir, "tg_O_r_catchment.tif"))
tg_O_catchment <- rasterToPolygons(tg_O_catchment, dissolve = T)
## Construct continuous dataset
ndvi <- tg_O_r
ndvi@data@values <- runif(n = (ndvi@ncols * ndvi@nrows), min = 0, max = 1)
names(ndvi) <- "ndvi"
## Continuous dataset and roi over which statistics will be calculation
plot(ndvi, main = "NDVI values")
plot(tg_O_r, col = "red", add = T, legend = FALSE)
plot(tg_O_catchment, add=T, col = adjustcolor("blue", alpha.f = 0.5))
legend("bottom", legend = c("lake", "lake catchment"), fill = c("red", adjustcolor("blue", alpha.f = 0.5)), horiz = TRUE, bty = "n")
## Foreach distance weight from hydroweight_test above, calculate the landscape statistics for ndvi
hydroweight_attribute_test_numeric <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
return(test_numericraster)
}
## Results structure
length(hydroweight_attribute_test_numeric) # 7 distance-weighted rasters
hydroweight_attribute_test_numeric[[1]][[1]] # attribute summary table
hydroweight_attribute_test_numeric[[1]][[2]] # processed loi raster used in calculations
#hydroweight_attribute_test_numeric[[1]][[3]] # processed distance-weighted raster used in calculations
?cellStats
?hydroweight::hydroweight
?hydroweight::hydroweight_attributes
(loi_median <- cellStats(loi_r_mask, stat = "median", na.rm=T))
?cellStats
?calc
devtools::load_all(".")
## Generate catchment for lake
tg_O_r <- toy_dem<220
tg_O_r[tg_O_r@data@values != 1] <- NA
writeRaster(tg_O_r, file.path(hydroweight_dir, "tg_O_r.tif"), overwrite = TRUE)
wbt_watershed(
d8_pntr = file.path(hydroweight_dir, "toy_dem_breached_d8.tif"),
pour_pts = file.path(hydroweight_dir, "tg_O_r.tif"),
output = file.path(hydroweight_dir, "tg_O_r_catchment.tif"))
tg_O_catchment <- raster(file.path(hydroweight_dir, "tg_O_r_catchment.tif"))
tg_O_catchment <- rasterToPolygons(tg_O_catchment, dissolve = T)
## Construct continuous dataset
ndvi <- tg_O_r
ndvi@data@values <- runif(n = (ndvi@ncols * ndvi@nrows), min = 0, max = 1)
names(ndvi) <- "ndvi"
## Continuous dataset and roi over which statistics will be calculation
plot(ndvi, main = "NDVI values")
plot(tg_O_r, col = "red", add = T, legend = FALSE)
plot(tg_O_catchment, add=T, col = adjustcolor("blue", alpha.f = 0.5))
legend("bottom", legend = c("lake", "lake catchment"), fill = c("red", adjustcolor("blue", alpha.f = 0.5)), horiz = TRUE, bty = "n")
## Foreach distance weight from hydroweight_test above, calculate the landscape statistics for ndvi
hydroweight_attribute_test_numeric <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
return(test_numericraster)
}
## Results structure
length(hydroweight_attribute_test_numeric) # 7 distance-weighted rasters
hydroweight_attribute_test_numeric[[1]][[1]] # attribute summary table
hydroweight_attribute_test_numeric[[1]][[2]] # processed loi raster used in calculations
#hydroweight_attribute_test_numeric[[1]][[3]] # processed distance-weighted raster used in calculations
## Extract results and apply name changes to specify distance-weighting
results <- foreach(x = 1:length(hydroweight_attribute_test_numeric), .errorhandling = "pass") %do% {
(names_hwtn <- names(hydroweight_test)[x])
(names_hwtn <- paste0(names_hwtn, "_", colnames(hydroweight_attribute_test_numeric[[x]][[1]])[-1]))
(names_hwtn <- gsub("_inv", "", names_hwtn))
colnames(hydroweight_attribute_test_numeric[[x]][[1]])[-1] <- names_hwtn
return(hydroweight_attribute_test_numeric[[x]])
}
## Extract only the summary table and bind results, see names of dataframe
results_agg <- lapply(results, function(x){x[[1]]})
results_agg <- Reduce(merge, results_agg)
names(results_agg)
## Foreach distance weight from hydroweight_test above, calculate the landscape statistics for ndvi
hydroweight_attribute_test_numeric <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
return(test_numericraster)
}
length(hydroweight_attribute_test_numeric) # 7 distance-weighted rasters
hydroweight_attribute_test_numeric[[1]][[1]] # attribute summary table
devtools::load_all(".")
x=1
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
library(hydroweight)
library(dplyr)
library(foreach)
library(hydroweight)
library(raster)
library(rgeos)
library(sf)
library(sp)
library(viridis)
library(whitebox)
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
devtools::install()
devtools::load_all(".")
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
(loi_median <- median(loi_r_mask@data@values, na.rm = T))
ndvi <- tg_O_r
ndvi@data@values <- runif(n = (ndvi@ncols * ndvi@nrows), min = 0, max = 1)
names(ndvi) <- "ndvi"
## Continuous dataset and roi over which statistics will be calculation
plot(ndvi, main = "NDVI values")
plot(tg_O_r, col = "red", add = T, legend = FALSE)
plot(ndvi, main = "NDVI values")
plot(tg_O_r, col = "red", add = T, legend = FALSE)
plot(ndvi, main = "NDVI values")
plot(tg_O_r, col = "red", add = T, legend = FALSE)
plot(tg_O_catchment, add=T, col = adjustcolor("blue", alpha.f = 0.5))
legend("bottom", legend = c("lake", "lake catchment"), fill = c("red", adjustcolor("blue", alpha.f = 0.5)), horiz = TRUE, bty = "n")
roi = tg_O_catchment
loi = ndvi
loi_numeric = TRUE
distance_weight = hydroweight_test[[x]]
remove_region = tg_O
resample = "bilinear"
return_products = TRUE
uid = "1"
uid_col = "site"
attr_col = "ndvi"
if(class(loi)[1] == "RasterLayer"){
message("\n Reprojecting `loi` to `distance_weight` extent, resolution, and origin.
This could be very slow given our choice of algorithm.
Consider reprojecting loi before this step.")
loi_r <- raster::projectRaster(from = loi,
to  = distance_weight,
method = resample)
}
if(class(loi)[1] =="sf"){
if(loi_numeric == TRUE){
loi_r <- lapply(loi_categories, function(x){
loi_return <- fasterize::fasterize(loi, raster = distance_weight,
field = x)
})
names(loi_r) <- loi_categories
loi_r <- brick(loi_r)
}
if(loi_numeric == FALSE){
loi_r <- lapply(loi_categories, function(x){
brick_ret <- fasterize::fasterize(loi, raster = distance_weight,
by = x)
names(brick_ret) <- paste0(x, names(brick_ret))
brick_ret
})
loi_r <- brick(loi_r)
}
}
## Mask to roi
if(class(roi)[1] == "sf"){
roi_r <-  fasterize::fasterize(roi, raster = distance_weight)
} else {
roi_r <- roi
}
loi_r_mask <- raster::mask(loi_r, roi_r)
distance_weight_mask <- raster::mask(distance_weight, roi_r)
## Mask out region
if(!is.null(remove_region)){
if(class(remove_region)[1] == "sf"){
remove_region_r <-  fasterize::fasterize(remove_region, raster = distance_weight)
} else {
remove_region_r <- remove_region
}
loi_r_mask <- raster::mask(loi_r_mask, remove_region_r,
inverse = TRUE)
distance_weight_mask <- raster::mask(distance_weight_mask, remove_region_r,
inverse = TRUE)
}
(loi_dist <- loi_r_mask * distance_weight_mask)
names(loi_dist) <- names(loi_r_mask)
## Weighted mean
(loi_distwtd_mean <- cellStats(loi_dist, stat = "sum", na.rm = TRUE) / cellStats(distance_weight_mask, stat = "sum", na.rm=T))
## Weighted standard deviation
## https://stats.stackexchange.com/questions/6534/how-do-i-calculate-a-weighted-standard-deviation-in-excel
(term1 <- cellStats( (distance_weight_mask * (loi_r_mask - loi_distwtd_mean)^2), stat = "sum", na.rm = TRUE))
(M <- cellStats(distance_weight_mask !=0, "sum", na.rm = T))
(term2 <- ((M-1)/M) * cellStats(distance_weight_mask, stat = "sum", na.rm = TRUE))
(loi_distwtd_sd <- sqrt(term1/term2))
## Non-weighted statistics
(loi_median <- median(loi_r_mask@data@values, na.rm = T))
(loi_min <- cellStats(loi_r_mask, stat = "min", na.rm=T))
(loi_max <- cellStats(loi_r_mask, stat = "max", na.rm=T))
(loi_sum <- cellStats(loi_r_mask, stat = "sum", na.rm=T))
(loi_pixel_is_na <- !is.na(loi_r_mask))
(loi_pixel_count <- cellStats(loi_pixel_is_na, "sum", na.rm=T))
loi_stats <- data.frame(loi_distwtd_mean, loi_distwtd_sd,
loi_median, loi_min, loi_max,
loi_sum, loi_pixel_count)
loi_stats$cats <- rownames(loi_stats)
loi_stats <- tidyr::pivot_wider(loi_stats, values_from = c(loi_distwtd_mean, loi_distwtd_sd,
loi_median, loi_min, loi_max,
loi_sum, loi_pixel_count), names_from = cats)
colnames(loi_stats) <- gsub("loi_", "", colnames(loi_stats))
(vars_strings <- stringr::str_extract(colnames(loi_stats), loi_categories))
(stats_strings <- stringr::str_replace(colnames(loi_stats), paste0("_", loi_categories), ""))
(colnames_strings <- paste(vars_strings, stats_strings, sep = "_"))
loi_stats <- as.data.frame(loi_stats)
colnames(loi_stats) <- paste(attr_col, colnames_strings, "_")
loi_stats <- as.data.frame(loi_stats)
loi_stats
devtools::load_all(".")
hydroweight_attribute_test_numeric <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
return(test_numericraster)
}
length(hydroweight_attribute_test_numeric) # 7 distance-weighted rasters
hydroweight_attribute_test_numeric[[1]][[1]] # attribute summary table
test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
loi = ndvi,
loi_numeric = TRUE,
distance_weight = hydroweight_test[[x]], ## Important to change
remove_region = tg_O,
resample = "bilinear",
return_products = TRUE,
uid = "1",
uid_col = "site",
attr_col = "ndvi")
if(class(loi)[1] == "RasterLayer"){
message("\n Reprojecting `loi` to `distance_weight` extent, resolution, and origin.
This could be very slow given our choice of algorithm.
Consider reprojecting loi before this step.")
loi_r <- raster::projectRaster(from = loi,
to  = distance_weight,
method = resample)
}
if(class(loi)[1] =="sf"){
if(loi_numeric == TRUE){
loi_r <- lapply(loi_categories, function(x){
loi_return <- fasterize::fasterize(loi, raster = distance_weight,
field = x)
})
names(loi_r) <- loi_categories
loi_r <- brick(loi_r)
}
if(loi_numeric == FALSE){
loi_r <- lapply(loi_categories, function(x){
brick_ret <- fasterize::fasterize(loi, raster = distance_weight,
by = x)
names(brick_ret) <- paste0(x, names(brick_ret))
brick_ret
})
loi_r <- brick(loi_r)
}
}
## Mask to roi
if(class(roi)[1] == "sf"){
roi_r <-  fasterize::fasterize(roi, raster = distance_weight)
} else {
roi_r <- roi
}
loi_r_mask <- raster::mask(loi_r, roi_r)
distance_weight_mask <- raster::mask(distance_weight, roi_r)
## Mask out region
if(!is.null(remove_region)){
if(class(remove_region)[1] == "sf"){
remove_region_r <-  fasterize::fasterize(remove_region, raster = distance_weight)
} else {
remove_region_r <- remove_region
}
loi_r_mask <- raster::mask(loi_r_mask, remove_region_r,
inverse = TRUE)
distance_weight_mask <- raster::mask(distance_weight_mask, remove_region_r,
inverse = TRUE)
}
if(loi_numeric == TRUE){
(loi_dist <- loi_r_mask * distance_weight_mask)
names(loi_dist) <- names(loi_r_mask)
## Weighted mean
(loi_distwtd_mean <- cellStats(loi_dist, stat = "sum", na.rm = TRUE) / cellStats(distance_weight_mask, stat = "sum", na.rm=T))
## Weighted standard deviation
## https://stats.stackexchange.com/questions/6534/how-do-i-calculate-a-weighted-standard-deviation-in-excel
(term1 <- cellStats( (distance_weight_mask * (loi_r_mask - loi_distwtd_mean)^2), stat = "sum", na.rm = TRUE))
(M <- cellStats(distance_weight_mask !=0, "sum", na.rm = T))
(term2 <- ((M-1)/M) * cellStats(distance_weight_mask, stat = "sum", na.rm = TRUE))
(loi_distwtd_sd <- sqrt(term1/term2))
## Non-weighted statistics
(loi_median <- median(loi_r_mask@data@values, na.rm = T))
(loi_min <- cellStats(loi_r_mask, stat = "min", na.rm=T))
(loi_max <- cellStats(loi_r_mask, stat = "max", na.rm=T))
(loi_sum <- cellStats(loi_r_mask, stat = "sum", na.rm=T))
(loi_pixel_is_na <- !is.na(loi_r_mask))
(loi_pixel_count <- cellStats(loi_pixel_is_na, "sum", na.rm=T))
loi_stats <- data.frame(loi_distwtd_mean, loi_distwtd_sd,
loi_median, loi_min, loi_max,
loi_sum, loi_pixel_count)
loi_stats$cats <- rownames(loi_stats)
loi_stats <- tidyr::pivot_wider(loi_stats, values_from = c(loi_distwtd_mean, loi_distwtd_sd,
loi_median, loi_min, loi_max,
loi_sum, loi_pixel_count), names_from = cats)
colnames(loi_stats) <- gsub("loi_", "", colnames(loi_stats))
(vars_strings <- stringr::str_extract(colnames(loi_stats), loi_categories))
(stats_strings <- stringr::str_replace(colnames(loi_stats), paste0("_", loi_categories), ""))
(colnames_strings <- paste(vars_strings, stats_strings, sep = "_"))
loi_stats <- as.data.frame(loi_stats)
colnames(loi_stats) <- paste(attr_col, colnames_strings, "_")
loi_stats <- as.data.frame(loi_stats)
}
