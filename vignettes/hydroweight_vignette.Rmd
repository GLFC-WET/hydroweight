---
title: "hydroweight: Inverse distance-weighted rasters and attributes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hydroweight_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 1.0 Introduction

Environmental scientists often want to calculate landscape statistics within upstream areas (i.e., catchments) 
to examine their potential effects on a target (e.g., stream network point or waterbody of interest). 
Practitioners typically use a "lumped" approach; this approach gives equal weight 
to areas nearby and those farther away from the target when calculating landscape statistics like 
proportion of urban cover upstream (Peterson et al. 2011). 

A more spatially explicit approach might be to generate buffers of successive distances 
away from the target and calculate the lumped statistics. For example, the proportion
or urban cover upstream in a buffer of 250 m and 1000 m from the target (Kielstra et al. 2019). 

Another spatially explicit approach is to calculate those statistics based 
on distances to the target, where areas nearby have more weight than those farther away 
(i.e., inverse distance-weighting). A set of inverse distance-weighted scenarios 
for stream survey sites was described in Peterson *et al.* (2011). Tools are implemented 
as *IDW-Plus* in *ArcGIS* (Peterson et al. 2017) as well as in *rdwplus* in R 
through GRASS GIS (Pearse et al. 2019).   

***hydroweight*** replicates this approach and further provides a set of simple and 
flexible functions to accommodate a wider set of scenarios and statistics 
through WhiteboxTools (e.g., numeric rasters and categorical rasters). 
WhiteboxTools (Lindsay 2016, Wu 2020). Some advantages of **hydroweight**: 

* users can provide numeric rasters to be summarized (summary statistics: 
inverse distance-weighted mean, inverse distance-weighted standard deviation, 
median, sum, min, max, pixel count). Input rasters are converted to the digital elevation model coordinate reference system.
* users can provide polygon layers to be summarized (either categorical or numeric data). 
Polygons are converted to rasters with the digital elevation model coordinate reference system. 
* users can script and work with the set of speedy WhiteboxTools through R. 

There are two functions: 

* `hydroweight()` generates distance-weighted rasters for targets
on a digital elevation model raster. Examples of targets include single points,
areas such as lakes, or linear features such as streams. The function outputs
a list of `length(weighting_scheme)` and an accompanying `*.rds` file
of distance-weighted rasters for targets (`target_O` is a point/area target as
in iFLO and `target_S` is a stream/waterbody target as in iFLS in
Peterson *et al.* 2011). IMPORTANTLY, this function produces one instance of 
the weighting (i.e., one target and multiple weight options).
Distance-weighted rasters, in turn, can be used in producing distance-weighted
attributes using `hydroweight::hydroweight_attributes()` (e.g., % urban
cover weighted by flow distance to a point). A workflow is provided below to 
include more targets.

* `hydroweight_attributes()` calculates distance-weighted attributes using 
distance-weighted rasters generated in `hydroweight()`, a region of interest
(`roi`, e.g., a catchment polygon), and an attribute layer (`loi`, e.g., land 
use raster/polygon). The function outputs an attribute summary table or a list  
that includes the summary table and layers used for calculation. Summary statistics 
are calculated as in Peterson *et al.* (2011). IMPORTANTLY, this function only 
produces one instance of the layer x weight summary statistics (i.e., one `roi`, 
one `loi`, and one `distance_weight`). A workflow is provided below to include
more targets and layers.

## 2.0 System setup 

The most critical component of running `hydroweight::` is having an 
an installation of WhiteboxTools. See https://github.com/giswqs/whiteboxR for 
installation instructions or here:

```{r} 
## Follow instructions for whitebox installation accordingly

# install.packages("whitebox", repos="http://R-Forge.R-project.org")
# whitebox::wbt_init()

```
## 3.0 Generate inverse distance-weighted rasters using `hydroweight()`

`hydroweight()` generates distance-weighted rasters for targets
on a digital elevation model raster. Examples of targets include single points,
areas such as lakes, or linear features such as streams. The function outputs
a list of `length(weighting_scheme)` and an accompanying `*.rds` file
of distance-weighted rasters for targets (`target_O` is a point/area target as
in iFLO and `target_S` is a stream/waterbody target as in iFLS in
Peterson *et al.* 2011). 

IMPORTANTLY, this function produces one instance of 
the weighting (i.e., one target and multiple weight options).
Distance-weighted rasters, in turn, can be used in producing distance-weighted
attributes using `hydroweight::hydroweight_attributes()` (e.g., % urban
cover weighted by flow distance to a point). A workflow is provided below to 
include more targets.

### 3.1 Generate toy dataset

This workflow moves from a digital elevation model to distance-weighted rasters 
using a toy dataset. First, we generate ensure continuous flow using wbt::breach_depressions, 
calculate the flow accumulation in units of cells using the d8 algorithm, and extract cells that have 
at least accumulated 2000 cells as our streams.

```{r, echo = FALSE}

library(dplyr)
library(foreach) 
library(hydroweight) 
library(raster)
library(rgeos)
library(sf) 
library(sp)
library(viridis)
library(whitebox)

devtools::load_all()

## Import toy_dem from whitebox package
toy_file <- system.file("extdata", "DEM.tif", package="whitebox")
toy_dem <- raster::raster(toy_file, values  = TRUE)
raster::crs(toy_dem)<-CRS("+init=epsg:3161") # arbitrary

## Generate hydroweight_output dir
hydroweight_dir <- tempdir()

## Write toy_dem and run some processing through whitebox
raster::writeRaster(toy_dem,
                    file.path(hydroweight_dir, "toy_dem.tif"), overwrite = T)

## Breach depressions to ensure continuous flow
wbt_breach_depressions(file.path(hydroweight_dir, "toy_dem.tif"),
                       file.path(hydroweight_dir, "toy_dem_breached.tif"))

## Generate d8 flow pointer 
wbt_d8_pointer(dem = file.path(hydroweight_dir, "toy_dem_breached.tif"), 
               output = file.path(hydroweight_dir, "toy_dem_breached_d8.tif"))

## Generate d-8 flow accumulation in units of cells
wbt_d8_flow_accumulation(input = file.path(hydroweight_dir, "toy_dem_breached.tif"), 
                          output = file.path(hydroweight_dir, "toy_dem_breached_accum.tif"), 
                          out_type = "cells")

## Generate streams with a stream initiation threshold of 2000 cells
wbt_extract_streams(file.path(hydroweight_dir, "toy_dem_breached_accum.tif"),
                    file.path(hydroweight_dir, "toy_dem_streams.tif"),
                    threshold = 2000)

```

### 3.2 Construct targets

Next we construct our targets. Here, our target is a low lying area we will call 
a lake (`tg_O`). All cells <220 m elevation are `TRUE` or `1` and those >220 m are 
assigned `NA`. The raster of positive cells are converted to a polygon to 
represent the lake. Target streams (`tg_S`) are loaded from the 
`whitebox::wbt_extract_streams()` output.

```{r, fig.width = 7, fig.height = 7}
## For hydroweight, there are target_O and target_S
## target_O is a target point/area for calculating distances
## target_S is a stream/waterbody target for calculating distances

## Generate target_0, tg_O
tg_O <- toy_dem<220
tg_O[tg_O@data@values != 1] <- NA
tg_O <- raster::rasterToPolygons(tg_O, dissolve = TRUE)
tg_O <- sf::st_as_sf(tg_O)

## Generate target_S, tg_S 
tg_S <- raster::raster(file.path(hydroweight_dir, "toy_dem_streams.tif"))

plot(toy_dem, legend = TRUE, col=viridis(10), main = "Toy DEM")
plot(tg_O, col="red", add = T, legend = FALSE)
plot(tg_S, col="blue", add = T, legend = FALSE)
legend("bottom", legend = c("target_O = tg_O", "target_S = tg_S"), fill = c("red", "blue"), horiz = TRUE, bty = "n" )
```

### 3.3 Run `hydroweight()`

Now we run the `hydroweight::hydroweight()` function using our lake as a `target_O`
for EucO, FLO, and HAFLO and our streams as `target_S` for EucS, FLS, and HAFLS. Using 
`OS_combine = TRUE`, we indicate that we'd like distances to be calculated to the nearest 
waterbody (either the lake or streams) and that, for HAFLO or HAFLS, that both lake and streams 
will be set to NoData for their calculation. Using `clip_region = 8000`, we indicate that 
we'd like an 8000 m buffer applied to the lake and only values within that region will be used 
for all further calculations. Our `dem` and `flow_accum` are assigned with character 
strings. Our weighting schemes are and the inverse function are indicated. Finally, we assign 
a unique identifier that will be used when exporting the result of `hydroweight::hydroweight()` 
to `hydroweight_dir`.

```{r, fig.width = 6, fig.height = 3}
## Generate inverse distance-weighting function
myinv <- function(x){ (x * 0.001 + 1)^-1 }

## Run hydroweight
hydroweight_test <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O,
  target_S = tg_S,
  OS_combine = TRUE,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO",
                       "EucS", "FLS", "HAFLS"),
  inv_function = myinv,
  uid = "1"
)

length(hydroweight_test) ## 1 set of targets and 7 distance-weighted rasters

## Plot different weighting schemes; Purple --> yellow == low --> high weight
par(mfrow=c(2,4), mar=c(1,1,1,1), oma = c(0,0,0,0))
layout(matrix(c(1, 2, 3, 4,
                1, 5, 6, 7), nrow = 2, byrow = TRUE))
plot(hydroweight_test[[1]], main=names(hydroweight_test)[1], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[2]], main=names(hydroweight_test)[2], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[3]], main=names(hydroweight_test)[2], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(log(hydroweight_test[[4]]), main=names(hydroweight_test)[3], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot.new()
plot(hydroweight_test[[5]], main=names(hydroweight_test)[4], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[6]], main=names(hydroweight_test)[5], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(log(hydroweight_test[[7]]), main=names(hydroweight_test)[6], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))

```

Important things to note from this plot: 

* The region was clipped by an 8000 m buffer extended outward from `target_O`. 
* HAFLO and HAFLS were log transformed to visualize the result. 
* For FLO/HAFLO/FLS/HAFLS, only those cells contributing to the areas of interest are calculated (e.g., no radial pattern in EucO_inv as in lumped_inv)
* As in Peterson *et al.* (2011), for HAFLO and HAFLS, the targets are set to NoData (i.e., NA) since they likely represent concentrated flow areas. 

The temporary files made per instance of `hydroweight::hydroweight()`:

```{r}
list.files(hydroweight_dir)[grep("TEMP-", list.files(hydroweight_dir))]
```

Now ignoring target_O or ignoring target_S:

```{r}
## Ignoring target_O
hydroweight_test_no_O <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_S = tg_S,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("EucS", "FLS", "HAFLS"),
  inv_function = myinv,
  uid = "1"
)

length(hydroweight_test_no_O) ## 1 stream target and 3 distance weightings

## Ignoring target_S
hydroweight_test_no_S <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("EucO", "FLO", "HAFLO"),
  inv_function = myinv,
  uid = "1"
)

length(hydroweight_test_no_S) ## 1 area target and 3 distance weightings
```

### 3.4 Running `hydroweight()` across a sequence of sites

We wanted users an opportunity to access/investigate processed data as much as possible. 
For simplicity, we wanted only two functions that could fit within `for`-, `foreach`-, 
or `lapply`-like sequences when users are interested in calculating distance-weighted 
landscape statistics across many sites.

For implementing `hydroweight()` across many sites, we advocate the use of 
`foreach` since it is `lapply`-like and can pass on and over any errors 
for later fixing. Linking `foreach` with `doParallel` allows for parallel processing 
(e.g., `foreach(...) %dopar%`) but we have not tested `whitebox` using parallel 
processing (we suspect potentially big problems and burnt computers but we are not computer scientists). 

Additionally, `hydroweight()` exports an `.rds` of its result to `hydroweight_dir`. This 
allows users to assign the results of `hydroweight()` to an object in the current 
environment or to run `hydroweight()` alone and upload the `.rds` afterwards. See below. 


```{r}
## Generate column for unique id, put 5 instances in a list, bind together, 
## and assign unique identifiers - these are our new "sites"
tg_O$id <- 1
tg_O_x5 <- list(tg_O, tg_O, tg_O, tg_O, tg_O)
tg_O_x5 <- do.call(dplyr::bind_rows, tg_O_x5)  
tg_O_x5$id <- seq(1:5)  

## Use foreach() but could use lapply() as well.
hydroweight_test_x5 <- foreach(x = 1:5, .errorhandling = "pass") %do% {
  
  message("Running hydroweight for site ", x, " at ", Sys.time())
  
  hydroweight_test <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O_x5[x,],                      ### the important piece to change
  target_S = tg_S,
  OS_combine = TRUE,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO",
                       "EucS", "FLS", "HAFLS"),
  inv_function = myinv,
  uid = tg_O_x5$id[x]                          ### the important piece to change
  )

  return(hydroweight_test)
}  
  
length(hydroweight_test_x5) # 5 sites

length(hydroweight_test_x5[[1]]) # 7 distance-weighted rasters for each site

hydroweight_test_x5[[1]][[2]] # site 1, distance-weighted raster 1 

hydroweight_test_x5[[2]][[3]] # site 2, distance-weighted raster 2 

## Loading up data after if didn't assign as an object while running
hydroweight_dir_files <- list.files(hydroweight_dir, full.names = TRUE)
hydroweight_test_x5 <- hydroweight_dir_files[grep("_inv_distances.rds", hydroweight_dir_files)]
hydroweight_test_x5 <- lapply(hydroweight_test_x5, function(x) { readRDS(x) })
```

## 4.0 Generate inverse distance-weighted attributes using `hydroweight_attributes()`

`hydroweight_attributes()` calculates distance-weighted attributes using 
distance-weighted rasters generated in `hydroweight()`, a region of interest
(`roi`, e.g., a catchment polygon), and an attribute layer (`loi`, e.g., land 
use raster/polygon). The function outputs an attribute summary table or a list 
that includes the summary table and layers used for calculation. Summary statistics 
are calculated as in Peterson *et al.* (2011). 

IMPORTANTLY, this function only produces one instance of the layer x weight summary 
statistics (i.e., one `roi`, one `loi`, and one `distance_weight`). 
A workflow is provided below to include more targets and layers.

Applying the same approach as above (i.e., using `foreach()`), we can generate 
distance-weighted attributes for a single site across all of our distance-weighted rasters.
Remember that we clipped the distance-weighted rasters by 8000 m in the plots below.

### 4.1 Using a numeric raster layer of interest 

```{r, fig.width = 6, fig.height = 6}
## Generate catchment for lake 
tg_O_r <- toy_dem<220
tg_O_r[tg_O_r@data@values != 1] <- NA

writeRaster(tg_O_r, file.path(hydroweight_dir, "tg_O_r.tif"), overwrite = TRUE)

wbt_watershed(
  d8_pntr = file.path(hydroweight_dir, "toy_dem_breached_d8.tif"),
  pour_pts = file.path(hydroweight_dir, "tg_O_r.tif"), 
  output = file.path(hydroweight_dir, "tg_O_r_catchment.tif"))

tg_O_catchment <- raster(file.path(hydroweight_dir, "tg_O_r_catchment.tif"))
tg_O_catchment <- rasterToPolygons(tg_O_catchment, dissolve = T)

## Construct continuous dataset
ndvi <- tg_O_r 
ndvi@data@values <- runif(n = (ndvi@ncols * ndvi@nrows), min = 0, max = 1)
names(ndvi) <- "ndvi"

## Continuous dataset and roi over which statistics will be calculation
plot(ndvi, main = "NDVI values")
plot(tg_O_r, col = "red", add = T, legend = FALSE)
plot(tg_O_catchment, add=T, col = adjustcolor("blue", alpha.f = 0.5))
legend("bottom", legend = c("lake", "lake catchment"), fill = c("red", adjustcolor("blue", alpha.f = 0.5)), horiz = TRUE, bty = "n")

## Foreach distance weight from hydroweight_test above, calculate the landscape statistics for ndvi
hydroweight_attribute_test_numeric <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {

  test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
                                               loi = ndvi, 
                                               loi_numeric = TRUE, 
                                               distance_weight = hydroweight_test[[x]], ## Important 
                                               remove_region = tg_O, 
                                               resample = "bilinear", 
                                               return_products = TRUE, 
                                               uid = "1",
                                               uid_col = "site",
                                               attr_col = "ndvi")

return(test_numericraster)
}

## Results structure
length(hydroweight_attribute_test_numeric) # 7 distance-weighted rasters 
hydroweight_attribute_test_numeric[[1]][[1]] # attribute summary table 
hydroweight_attribute_test_numeric[[1]][[2]] # processed loi raster used in calculations
hydroweight_attribute_test_numeric[[1]][[3]] # processed distance-weighted raster used in calculations 

## Extract results and apply name changes to specify distance-weighting
results <- foreach(x = 1:length(hydroweight_attribute_test_categorical), .errorhandling = "pass") %do% { 
  
  (names_hwtn <- names(hydroweight_test)[x]) 
  (names_hwtn <- paste0(names_hwtn, "_", colnames(hydroweight_attribute_test_numeric[[x]][[1]])[-1]))
  (names_hwtn <- gsub("_inv", "", names_hwtn))
  
  colnames(hydroweight_attribute_test_numeric[[x]][[1]])[-1] <- names_hwtn
 
   return(hydroweight_attribute_test_numeric[[x]])
  
}

## Extract only the summary table and bind results, see names of dataframe
results_agg <- lapply(results, function(x){x[[1]]})
results_agg <- Reduce(merge, results_agg) 
names(results_agg)
``` 

```{r, fig.width=5, fig.height=10}

## Plot results
par(mfrow=c(3,2), mar=c(1,1,1,1), oma = c(0,0,0,0))

## Lumped 
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - loi")
plot(results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col="yellow", add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - loi * distance_weight")
plot(results[[1]]$`loi_Raster*_bounded` * results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)

## EucO
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi")
plot(results[[2]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi * distance_weight")
plot(results[[2]]$`loi_Raster*_bounded` * results[[2]]$distance_weight_bounded, main="Lumped \n- loi * distance_weight", axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)

## FLO 
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi")
plot(results[[3]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi * distance_weight")
plot(results[[3]]$`loi_Raster*_bounded` * results[[3]]$distance_weight_bounded, main="Lumped \n- loi * distance_weight", axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)



```

### 4.2 Using a categorical raster layer of interest 

```{r, fig.height = 3, fig.width = 6}
## Reclassify elevation values into categories
lulc <- toy_dem
m <- c(0, 220, 1, 220, 300, 2, 300, 400, 3, 400, Inf, 4)
rclmat <- matrix(m, ncol = 3, byrow = TRUE)
lulc <- reclassify(lulc, rclmat)

plot(lulc)
plot(tg_O_catchment, col = adjustcolor("blue", alpha.f = 0.5), add = T)

## Run hydroweight attributes
hydroweight_attribute_test_categorical <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
  
  test_categoricalraster <- hydroweight_attributes(roi = tg_O_catchment,
                                               loi = lulc, 
                                               loi_numeric = FALSE, 
                                               distance_weight = hwr, 
                                               remove_region = tg_O, 
                                               resample = "ngb", 
                                               return_products = TRUE, 
                                               uid = "1",
                                               uid_col = "site",
                                               attr_col = "lulc", 
                                               )
}

## Results structure
length(hydroweight_attribute_test_categorical) # 7 distance-weighted rasters 
hydroweight_attribute_test_categorical[[1]][[1]] # attribute summary table 
hydroweight_attribute_test_categorical[[1]][[2]] # processed loi raster used in calculations, RasterBrick
hydroweight_attribute_test_categorical[[1]][[2]][[1]] # processed loi raster used in calculations, RasterLayer category 4 
hydroweight_attribute_test_categorical[[1]][[2]][[2]] # processed loi raster used in calculations, RasterLayer category 3
hydroweight_attribute_test_categorical[[1]][[2]][[3]] # processed loi raster used in calculations, RasterLayer category 2 
hydroweight_attribute_test_categorical[[1]][[3]] # processed distance-weighted raster used in calculations 

## Extract results and apply name changes to specify distance-weighting
results <- foreach(x = 1:length(hydroweight_attribute_test_categorical), .errorhandling = "pass") %do% { 
  
  (names_hwtn <- names(hydroweight_test)[x]) 
  (names_hwtn <- paste0(names_hwtn, "_", colnames(hydroweight_attribute_test_categorical[[x]][[1]])[-1]))
  (names_hwtn <- gsub("_inv", "", names_hwtn))
  
  colnames(hydroweight_attribute_test_categorical[[x]][[1]])[-1] <- names_hwtn
 
   return(hydroweight_attribute_test_categorical[[x]])
  
}

## Extract only the summary table and bind results, see names of dataframe
results_agg <- lapply(results, function(x){x[[1]]})
results_agg <- Reduce(merge, results_agg) 
names(results_agg)

## Plot results
par(mfrow=c(3,4), mar=c(1,1,1,1), oma = c(0,0,0,0))

## Lumped 
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - ")
plot(results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col="yellow", add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - loi * lulc (category: 4")
plot(results[[1]][[2]][[1]]* results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)


results[[1]][[2]][[2]]
results[[1]][[2]][[3]]





## EucO
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi")
plot(results[[2]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi * distance_weight")
plot(results[[2]]$`loi_Raster*_bounded` * results[[2]]$distance_weight_bounded, main="Lumped \n- loi * distance_weight", axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)

## FLO 
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi")
plot(results[[3]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi * distance_weight")
plot(results[[3]]$`loi_Raster*_bounded` * results[[3]]$distance_weight_bounded, main="Lumped \n- loi * distance_weight", axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)





```

### 4.3 Using a polygon layer of interest with numeric data in the column 

### 4.4 Using a polygon layer of interest with categorical data in the column 

### 4.5 Running hydroweight_attributes() across a sequence of sites 

### 4.6 Running hydroweight_attributes() across a sequence of sites and layers of interest

## 5.0 References

Kielstra, B. W., Chau, J., & Richardson, J. S. (2019). Measuring function and structure of urban headwater streams with citizen scientists. Ecosphere, 10(4):e02720. https://doi.org/10.1002/ecs2.2720

Lindsay J.B. (2016). Whitebox GAT: A case study in geomorphometric analysis. Computers & Geosciences, 95: 75-84. https://doi.org/10.1016/j.cageo.2016.07.003

Peterson, E. E., Sheldon, F., Darnell, R., Bunn, S. E., & Harch, B. D. (2011). A comparison of spatially explicit landscape representation methods and their relationship to stream condition. Freshwater Biology, 56(3), 590–610. https://doi.org/10.1111/j.1365-2427.2010.02507.x

Peterson, E. E. & Pearse, A. R. (2017). IDW‐Plus: An ArcGIS Toolset for calculating spatially explicit watershed attributes for survey sites. 
Journal of the American Water Resources Association, 53(5): 1241–1249. https://doi.org/10.1111/1752-1688.12558 

Pearse A., Heron G., & Peterson E. (2019). rdwplus: An Implementation of IDW-PLUS. R package version 0.1.0. https://CRAN.R-project.org/package=rdwplus

Wu Q. (2020). whitebox: 'WhiteboxTools' R Frontend. R package version 1.4.0. https://github.com/giswqs/whiteboxR



## Construct a toy raster and polygon dataset 
lulc <- ndvi
lulc@data@values <- sample(c(1,2,3), size = length(lulc@data@values), replace = TRUE)
lulc_p <- raster::rasterToPolygons(lulc)

hist(lulc@data@values)
plot(lulc)
plot(lulc_p)

# ## 1) Construct a toy dataset ----
# 
# NC_lkscapes <- lkscape_ih[lkscape_ih_bsm]
# length(NC_lkscapes)
# 
# ## boundary 
# b <- st_union((NC_lkscapes[[2]][[3]]))
# b <- st_as_sf(b)
# plot(b)
# 
# ## land cover classes polygon
# lulc <- NC_lkscapes[[2]][[3]]
# lulc$ulc <- sample(c(100, 200, 300), size = 10, replace=T)
# lulc$grad_1 <- lulc$ulc 
# lulc$grad_2 <- lulc$ulc^2 * 0.75
# st_area(lulc)/st_area(b) # 74% and 0.008%
# 
# plot(b, col="lightgrey", border="lightgrey")
# plot(lulc["ulc"], add=T)
# plot(lulc["grad_1"], add=T)
# plot(lulc["grad_2"], add=T)
# 
# ## continuous
# ndvi <- dw
# (ndvi@data@values <- rnorm(n = length(ndvi@data@values), mean = 0, sd = 0.25))
# names(ndvi) <- "ndvi"
# 
# ## remove region (i.e., not included in calculation) 
# lake <- NC_lkscapes[[2]][[1]]
# plot(st_geometry(lake), add=T, col="lightblue")
# 
# ## distance_weight
# dw <- lkscape_ih_hydrology[[2]][[1]]
# 
# ## Real example, raster ---- 
# plot(ndvi)
# plot(b, add=T)
# 
# test_realraster <- hydroweight_attributes(boundary = b,
#                                           remove_region = lake,
#                                           distance_weight = dw,
#                                           layer = ndvi,
#                                           real = TRUE, 
#                                           resample = "bilinear", 
#                                           return_products = TRUE
# )
# test_realraster
# par(mfrow=c(1,3))
# plot(test_realraster[[2]], axes=F, legend=F, main = "data")
# plot(test_realraster[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(test_realraster[[2]] * test_realraster[[3]], main = "data * distance_weighting")
# 
# ## Real example, raster unweighted ----
# test_realraster_uw <- hydroweight_attributes(boundary = b,
#                                              remove_region = lake,
#                                              distance_weight = dw>0,
#                                              layer = ndvi,
#                                              real = TRUE, 
#                                              resample = "bilinear", 
#                                              return_products = TRUE
# )
# 
# viz <- test_realraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# 
# ## Categorical Example, raster weighted----
# lulc_rast <- fasterize::fasterize(lulc, raster = dw, 
#                                   field = "ulc")
# plot(lulc_rast)
# 
# test_categoricalraster <- hydroweight_attributes(boundary = b,
#                                                  remove_region = lake,
#                                                  distance_weight = dw,
#                                                  categories = NULL,
#                                                  layer = lulc_rast,
#                                                  real = FALSE, 
#                                                  resample = "ngb", 
#                                                  return_products = TRUE
# )
# 
# viz <- test_categoricalraster
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]])
# viz[[1]]
# 
# test_categoricalraster_uw <- hydroweight_attributes(boundary = b,
#                                                     remove_region = lake,
#                                                     distance_weight = dw>0,
#                                                     categories = NULL,
#                                                     layer = lulc_rast,
#                                                     real = FALSE, 
#                                                     resample = "ngb", 
#                                                     return_products = TRUE
# )
# 
# viz <- test_categoricalraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]]) # should be summing to 1
# viz[[1]]
# 
# ## Real example, from polygon column ----
# 
# test_realpolygon <- hydroweight_attributes(boundary = b,
#                                            remove_region = lake,
#                                            distance_weight = dw,
#                                            categories = c("grad_1", "grad_2"),
#                                            layer = lulc,
#                                            real = TRUE, 
#                                            resample = "ngb", 
#                                            return_products = TRUE
# )
# 
# viz <- test_realpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_realpolygon_uw <- hydroweight_attributes(boundary = b,
#                                               remove_region = lake,
#                                               distance_weight = dw>0,
#                                               categories = c("grad_1", "grad_2"),
#                                               layer = lulc,
#                                               real = TRUE, 
#                                               resample = "ngb", 
#                                               return_products = TRUE
# )
# 
# viz <- test_realpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## Categorical example, from polygon column ----
# 
# test_categoricalpolygon <- hydroweight_attributes(boundary = b,
#                                                   remove_region = lake,
#                                                   distance_weight = dw,
#                                                   categories = c("grad_1", "grad_2"),
#                                                   layer = lulc,
#                                                   real = FALSE, 
#                                                   resample = "bilinear", 
#                                                   return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_categoricalpolygon_uw <- hydroweight_attributes(boundary = b,
#                                                      remove_region = lake,
#                                                      distance_weight = dw>0,
#                                                      categories = c("grad_1", "grad_2"),
#                                                      layer = lulc,
#                                                      real = FALSE, 
#                                                      resample = "bilinear", 
#                                                      return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 



```




# ## ***********************
# ## TEST - HYDROWEIGHT ----
# ## *********************** 
# 
 
# ## Write toy_dem and run some processing through whitebox
# raster::writeRaster(toy_dem, 
#                     file.path(hydroweight_dir, "toy_dem.tif"), overwrite = T)
# 
# wbt_breach_depressions(file.path(hydroweight_dir, "toy_dem.tif"), 
#                        file.path(hydroweight_dir, "toy_dem_breached.tif"))
# 
# wbt_d_inf_flow_accumulation(file.path(hydroweight_dir, "toy_dem_breached.tif"), 
#                             file.path(hydroweight_dir, "toy_dem_breached_accum.tif"), 
#                             out_type = "cells")
# 
# wbt_extract_streams(file.path(hydroweight_dir, "toy_dem_breached_accum.tif"), 
#                     file.path(hydroweight_dir, "toy_dem_streams.tif"),
#                     threshold = 2000)
# 
# ## For hydroweight, there are target_O and target_S 
# ## target_O is a target point or location for calculating distances 
# ## target_S is a stream/waterbody target for calculating distances 
# 
# ## Generate target_0
# tg <- toy_dem<220
# tg[tg@data@values != 1] <- NA
# tg <- raster::rasterToPolygons(tg, dissolve=T)
# tg <- sf::st_as_sf(tg)
# 
# plot(toy_dem)
# plot(tg, col="red", add=T)
# plot(streams, col="blue", add=T)
# 
# hydroweight_test <- hydroweight(
#   hydroweight_dir = "./out_spatial/hydroweight_output", 
#   target_O = tg, 
#   target_S = "toy_dem_streams.tif", 
#   target_OS = TRUE,
#   clip_region = 8000,
#   dem = "toy_dem_breached.tif", 
#   flow_accum = "toy_dem_breached_accum.tif", 
#   weighting_scheme = c("iEucO", "iFLO", "HAiFLO", 
#                        "iEucS", "iFLS", "HAiFLS"), 
#   inv_function = function(x){ (x * 0.001 + 1)^-1 },
#   uid = "1"
# )
# 
# par(mfrow=c(2,3), mar=c(1,1,3,1))
# plot(hydroweight_test[[1]], main=names(hydroweight_test)[1], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[2]], main=names(hydroweight_test)[2], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[3]], main=names(hydroweight_test)[3], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[4]], main=names(hydroweight_test)[4], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[5]], main=names(hydroweight_test)[5], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[6]], main=names(hydroweight_test)[6], axes=F, legend=F, col=viridis::viridis(10))

# ## **********************************
# ## TEST - HYDROWEIGHT_ATTRIBUTES ----
# ## ********************************** 
# 
# ## Construct toy watershed
# tg_shed <- st_buffer(tg, dist = 1000, endCapStyle = "SQUARE")
# hydroweight_extent <- st_as_sfc(st_bbox(extent(hydroweight_test[[1]])))
# st_crs(hydroweight_extent) <- st_crs(tg_shed)
# 
# tg_shed <- st_intersection(tg_shed, hydroweight_extent )
# 
# par(mfrow=c(1,1,))
# plot(hydroweight_test[[2]])
# plot(tg_shed, add=T)
# 
# ## Real example, raster ---- 
# 
# ## Construct continuous dataset 
# ndvi <- hydroweight_test[[1]]
# (ndvi@data@values <- runif(n = length(ndvi@data@values), min = 0, max = 1))
# 
# plot(ndvi)
# plot(tg_shed, add=T)
# 
# hydroweight_attribute_test_real <- lapply(hydroweight_test, function(hwr){
#   
#   test_realraster <- hydroweight_attributes(boundary = tg_shed,
#                                             remove_region = tg,
#                                             distance_weight = hwr,
#                                             layer = ndvi,
#                                             real = TRUE, 
#                                             resample = "bilinear", 
#                                             return_products = TRUE
#   )
#   
# })
# 
# results <- lapply(hydroweight_attribute_test_real, function(x){x[[1]]})
# results
# 
# 
# 
# ## 1) Construct a toy dataset ----
# 
# NC_lkscapes <- lkscape_ih[lkscape_ih_bsm]
# length(NC_lkscapes)
# 
# ## boundary 
# b <- st_union((NC_lkscapes[[2]][[3]]))
# b <- st_as_sf(b)
# plot(b)
# 
# ## land cover classes polygon
# lulc <- NC_lkscapes[[2]][[3]]
# lulc$ulc <- sample(c(100, 200, 300), size = 10, replace=T)
# lulc$grad_1 <- lulc$ulc 
# lulc$grad_2 <- lulc$ulc^2 * 0.75
# st_area(lulc)/st_area(b) # 74% and 0.008%
# 
# plot(b, col="lightgrey", border="lightgrey")
# plot(lulc["ulc"], add=T)
# plot(lulc["grad_1"], add=T)
# plot(lulc["grad_2"], add=T)
# 
# ## continuous
# ndvi <- dw
# (ndvi@data@values <- rnorm(n = length(ndvi@data@values), mean = 0, sd = 0.25))
# names(ndvi) <- "ndvi"
# 
# ## remove region (i.e., not included in calculation) 
# lake <- NC_lkscapes[[2]][[1]]
# plot(st_geometry(lake), add=T, col="lightblue")
# 
# ## distance_weight
# dw <- lkscape_ih_hydrology[[2]][[1]]
# 
# ## Real example, raster ---- 
# plot(ndvi)
# plot(b, add=T)
# 
# test_realraster <- hydroweight_attributes(boundary = b,
#                                           remove_region = lake,
#                                           distance_weight = dw,
#                                           layer = ndvi,
#                                           real = TRUE, 
#                                           resample = "bilinear", 
#                                           return_products = TRUE
# )
# test_realraster
# par(mfrow=c(1,3))
# plot(test_realraster[[2]], axes=F, legend=F, main = "data")
# plot(test_realraster[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(test_realraster[[2]] * test_realraster[[3]], main = "data * distance_weighting")
# 
# ## Real example, raster unweighted ----
# test_realraster_uw <- hydroweight_attributes(boundary = b,
#                                              remove_region = lake,
#                                              distance_weight = dw>0,
#                                              layer = ndvi,
#                                              real = TRUE, 
#                                              resample = "bilinear", 
#                                              return_products = TRUE
# )
# 
# viz <- test_realraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# 
# ## Categorical Example, raster weighted----
# lulc_rast <- fasterize::fasterize(lulc, raster = dw, 
#                                   field = "ulc")
# plot(lulc_rast)
# 
# test_categoricalraster <- hydroweight_attributes(boundary = b,
#                                                  remove_region = lake,
#                                                  distance_weight = dw,
#                                                  categories = NULL,
#                                                  layer = lulc_rast,
#                                                  real = FALSE, 
#                                                  resample = "ngb", 
#                                                  return_products = TRUE
# )
# 
# viz <- test_categoricalraster
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]])
# viz[[1]]
# 
# test_categoricalraster_uw <- hydroweight_attributes(boundary = b,
#                                                     remove_region = lake,
#                                                     distance_weight = dw>0,
#                                                     categories = NULL,
#                                                     layer = lulc_rast,
#                                                     real = FALSE, 
#                                                     resample = "ngb", 
#                                                     return_products = TRUE
# )
# 
# viz <- test_categoricalraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]]) # should be summing to 1
# viz[[1]]
# 
# ## Real example, from polygon column ----
# 
# test_realpolygon <- hydroweight_attributes(boundary = b,
#                                            remove_region = lake,
#                                            distance_weight = dw,
#                                            categories = c("grad_1", "grad_2"),
#                                            layer = lulc,
#                                            real = TRUE, 
#                                            resample = "ngb", 
#                                            return_products = TRUE
# )
# 
# viz <- test_realpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_realpolygon_uw <- hydroweight_attributes(boundary = b,
#                                               remove_region = lake,
#                                               distance_weight = dw>0,
#                                               categories = c("grad_1", "grad_2"),
#                                               layer = lulc,
#                                               real = TRUE, 
#                                               resample = "ngb", 
#                                               return_products = TRUE
# )
# 
# viz <- test_realpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## Categorical example, from polygon column ----
# 
# test_categoricalpolygon <- hydroweight_attributes(boundary = b,
#                                                   remove_region = lake,
#                                                   distance_weight = dw,
#                                                   categories = c("grad_1", "grad_2"),
#                                                   layer = lulc,
#                                                   real = FALSE, 
#                                                   resample = "bilinear", 
#                                                   return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_categoricalpolygon_uw <- hydroweight_attributes(boundary = b,
#                                                      remove_region = lake,
#                                                      distance_weight = dw>0,
#                                                      categories = c("grad_1", "grad_2"),
#                                                      layer = lulc,
#                                                      real = FALSE, 
#                                                      resample = "bilinear", 
#                                                      return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## ALL WORKS - OBVIOUSLY NEED BETTER EXAMPLES

# ## **********
## PLOTS ----
## ********** 

# ## 1) Distance weighted catchment influence ---- 
# 
# rescale_r <- function(x, x_min =NULL, x_max = NULL, new_min = 0, new_max = 1) {
#   if(is.null(x_min)) x_min = cellStats(x, min)
#   if(is.null(x_max)) x_max = cellStats(x, max)
#   new_min + (x - x_min) * ((new_max - new_min) / (x_max - x_min))
# }
# 
# ## Rasters to plot after running one instance of the loop
# iEucO_p <- hydroweight_attribute_test_real[[1]][[2]] * hydroweight_attribute_test_real[[1]][[3]]
# iFLO_p <- hydroweight_attribute_test_real[[2]][[2]] * hydroweight_attribute_test_real[[2]][[3]]
# HAiFLO_p <- hydroweight_attribute_test_real[[3]][[2]] * hydroweight_attribute_test_real[[3]][[3]]
# HAiFLO_p <- rescale_r(log(HAiFLO_p+1), new_min = 0, new_max = 1)
# iEucS_p <- hydroweight_attribute_test_real[[4]][[2]] * hydroweight_attribute_test_real[[4]][[3]]
# iFLS_p <- hydroweight_attribute_test_real[[5]][[2]] * hydroweight_attribute_test_real[[5]][[3]]
# HAiFLS_p <- hydroweight_attribute_test_real[[6]][[2]] * hydroweight_attribute_test_real[[6]][[3]]
# HAiFLS_p <- rescale_r(log(HAiFLS_p+1), new_min = 0, new_max = 1)
# 
# tiff(filename=paste0("./out_figs/", "Merc_DistanceWeightedCatchmentInfluence",
#                      Sys.Date(), ".tif"),
#      width=15, height=10, units="cm", res=300,
#      compression="lzw+p", type="cairo")
# 
# par(mfrow=c(2,3), oma=c(0,0,0,0), mar=c(0,0,2,0))
# plot(iEucO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iEucO")
# plot(tg_shed, add=T, col=NA, border="black")
# 
# plot(iFLO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iFLO")
# 
# plot(HAiFLO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "HA-iFLO")
# 
# plot(iEucS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iEucS")
# 
# plot(iFLS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iFLS")
# 
# plot(HAiFLS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "HA-iFLS")
# 
# dev.off()
# 
# hydroweight_attribute_test_real[[1]][[1]]


















