---
title: "hydroweight: Inverse distance-weighted rasters and attributes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hydroweight_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 1.0 Introduction

Environmental scientists often want to calculate landscape statistics within upstream contributing areas (i.e., catchments) 
to examine their potential effects on a target (e.g., stream network point or waterbody of interest). 
Practitioners typically use a "lumped" approach; this approach gives equal weight 
to areas nearby and those farther away from the target when calculating landscape statistics like 
proportion of urban cover upstream (Peterson et al. 2011). 

A more spatially explicit approach might be to generate buffers of successive distances 
away from the target and calculate the lumped statistics. For example, the proportion
or urban cover upstream in a buffer of 250 m and 1000 m from the target (Kielstra et al. 2019). 

Another spatially explicit approach is to calculate those statistics based 
on distances to the target, where areas nearby have more weight than those farther away 
(i.e., inverse distance-weighting). A set of inverse distance-weighted scenarios 
for stream survey sites was described in Peterson *et al.* (2011). Tools are implemented 
as *IDW-Plus* in *ArcGIS* (Peterson et al. 2017) as well as in *rdwplus* in R 
through GRASS GIS (Pearse et al. 2019).   

***hydroweight*** replicates this approach and further provides a set of simple and 
flexible functions to accommodate a wider set of scenarios and statistics 
through WhiteboxTools (e.g., numeric rasters and categorical rasters). 
WhiteboxTools (Lindsay 2016, Wu 2020). Some advantages of ***hydroweight***: 

* users can provide numeric rasters to be summarized (summary statistics: 
inverse distance-weighted mean, inverse distance-weighted standard deviation, 
median, sum, min, max, pixel count). Input rasters are converted to the digital elevation model coordinate reference system.
* users can provide polygon layers to be summarized (either categorical or numeric data). 
Polygons are converted to rasters with the digital elevation model coordinate reference system. 
* users can script and work with the set of speedy WhiteboxTools through R. 

There are two functions: 

* `hydroweight()` generates distance-weighted rasters for targets
on a digital elevation model raster. Examples of targets include single points,
areas such as lakes, or linear features such as streams. The function outputs
a list of `length(weighting_scheme)` and an accompanying `*.rds` file
of distance-weighted rasters for targets (`target_O` is a point/area target as
in iFLO and `target_S` is a stream/waterbody target as in iFLS in
Peterson *et al.* 2011). IMPORTANTLY, this function produces one instance of 
the weighting (i.e., one target and multiple weight options).
Distance-weighted rasters, in turn, can be used in producing distance-weighted
attributes using `hydroweight::hydroweight_attributes()` (e.g., % urban
cover weighted by flow distance to a point). A workflow is provided below to 
include more targets.

* `hydroweight_attributes()` calculates distance-weighted attributes using 
distance-weighted rasters generated in `hydroweight()`, a region of interest
(`roi`, e.g., a catchment polygon), and an attribute layer (`loi`, e.g., land 
use raster/polygon). The function outputs an attribute summary table or a list  
that includes the summary table and layers used for calculation. Summary statistics 
are calculated as in Peterson *et al.* (2011). IMPORTANTLY, this function only 
produces one instance of the layer x weight summary statistics (i.e., one `roi`, 
one `loi`, and one `distance_weight`). A workflow is provided below to include
more targets and layers.

## 2.0 System setup 

WhiteboxTools must be installed for ***hydroweight*** to run. Other libraries 
should be installed on installation of ***hydroweight***. 

See https://github.com/giswqs/whiteboxR for 
installation instructions or here:

```{r, eval = FALSE} 
## Follow instructions for whitebox installation accordingly

#TODO: Github Brian - Install hydroweight

install.packages("whitebox", repos="http://R-Forge.R-project.org")
whitebox::wbt_init()

```
## 3.0 Generate inverse distance-weighted rasters using `hydroweight()`

`hydroweight()` generates distance-weighted rasters for targets
on a digital elevation model raster. Examples of targets include single points,
areas such as lakes, or linear features such as streams. The function outputs
a list of `length(weighting_scheme)` and an accompanying `*.rds` file
of distance-weighted rasters for targets (`target_O` is a point/area target as
in iFLO and `target_S` is a stream/waterbody target as in iFLS in
Peterson *et al.* 2011). 

IMPORTANTLY, this function produces one instance of 
the weighting (i.e., one target and multiple weight options).
Distance-weighted rasters, in turn, can be used in producing distance-weighted
attributes using `hydroweight::hydroweight_attributes()` (e.g., % urban
cover weighted by flow distance to a point). A workflow is provided below to 
include more targets.

### 3.1 Generate toy dataset

This workflow moves from a digital elevation model to distance-weighted rasters 
using a toy dataset. First, we generate ensure continuous flow using wbt::breach_depressions, 
calculate the flow accumulation in units of cells using the d8 algorithm, and extract cells that have 
at least accumulated 2000 cells as our streams.

```{r, message = FALSE, error = FALSE}

library(dplyr)
library(foreach) 
library(hydroweight) 
library(raster)
library(rgeos)
library(sf) 
library(sp)
library(viridis)
library(whitebox)

devtools::load_all()

## Import toy_dem from whitebox package
toy_file <- system.file("extdata", "DEM.tif", package="whitebox")
toy_dem <- raster::raster(toy_file, values  = TRUE)
raster::crs(toy_dem)<-CRS("+init=epsg:3161")

## Generate hydroweight_output dir
hydroweight_dir <- tempdir()

## Write toy_dem to hydroweight_dir
raster::writeRaster(toy_dem,
                    file.path(hydroweight_dir, "toy_dem.tif"), overwrite = T)

## Breach depressions to ensure continuous flow
wbt_breach_depressions(file.path(hydroweight_dir, "toy_dem.tif"),
                       file.path(hydroweight_dir, "toy_dem_breached.tif"))

## Generate d8 flow pointer (note: other flow directions are available) 
wbt_d8_pointer(dem = file.path(hydroweight_dir, "toy_dem_breached.tif"), 
               output = file.path(hydroweight_dir, "toy_dem_breached_d8.tif"))

## Generate d8 flow accumulation in units of cells (note: other flow directions are available)
wbt_d8_flow_accumulation(input = file.path(hydroweight_dir, "toy_dem_breached.tif"), 
                          output = file.path(hydroweight_dir, "toy_dem_breached_accum.tif"), 
                          out_type = "cells")

## Generate streams with a stream initiation threshold of 2000 cells
wbt_extract_streams(file.path(hydroweight_dir, "toy_dem_breached_accum.tif"),
                    file.path(hydroweight_dir, "toy_dem_streams.tif"),
                    threshold = 2000)

```

### 3.2 Construct targets

Next we construct our targets. Here, our target is a low lying area we will call 
a lake (`tg_O`). All cells <220 m elevation are `TRUE` or `1` and those >220 m are 
assigned `NA`. The raster of positive cells are converted to a polygon to 
represent the lake. Target streams (`tg_S`) are loaded from the 
`whitebox::wbt_extract_streams()` output.

```{r, fig.width = 7, fig.height = 7, message = FALSE, error = FALSE}
## For hydroweight, there are target_O and target_S
## target_O is a target point/area for calculating distances
## target_S is a stream/waterbody target for calculating distances

## Generate target_0, tg_O
tg_O <- toy_dem<220
tg_O[tg_O@data@values != 1] <- NA
tg_O <- raster::rasterToPolygons(tg_O, dissolve = TRUE)
tg_O <- sf::st_as_sf(tg_O)

## Generate target_S, tg_S 
tg_S <- raster::raster(file.path(hydroweight_dir, "toy_dem_streams.tif"))

plot(toy_dem, legend = TRUE, col=viridis(10), main = "Toy DEM")
plot(tg_O, col="red", add = T, legend = FALSE)
plot(tg_S, col="blue", add = T, legend = FALSE)
legend("bottom", legend = c("target_O = tg_O", "target_S = tg_S"), fill = c("red", "blue"), horiz = TRUE, bty = "n" )
```

### 3.3 Run `hydroweight()`

Now we run the `hydroweight::hydroweight()` function using our lake as a `target_O`
for EucO, FLO, and HAFLO and our streams as `target_S` for EucS, FLS, and HAFLS. Using 
`OS_combine = TRUE`, we indicate that we'd like distances to be calculated to the nearest 
waterbody (either the lake or streams) and that, for HAFLO or HAFLS, that both lake and streams 
will be set to NoData for their calculation. Using `clip_region = 8000`, we indicate that 
we'd like an 8000 m buffer applied to the lake and only values within that region will be used 
for all further calculations. Our `dem` and `flow_accum` are assigned with character 
strings. Our weighting schemes are and the inverse function are indicated. Finally, we assign 
a unique identifier that will be used when exporting the result of `hydroweight::hydroweight()` 
to `hydroweight_dir`.

```{r, fig.width = 7, fig.height = 3.5, message = FALSE, error = FALSE}
## Generate inverse distance-weighting function
myinv <- function(x){ (x * 0.001 + 1)^-1 } ## 0.001 multiplier turns m to km

## Run hydroweight::hydroweight()
hydroweight_test <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O,
  target_S = tg_S,
  OS_combine = TRUE,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO",
                       "EucS", "FLS", "HAFLS"),
  inv_function = myinv,
  roi_uid = "1"
)

## Resultant structure:
# length(hydroweight_test) ## 1 set of targets and 7 distance-weighted rasters
# hydroweight_test[[1]] ## lumped
# hydroweight_test[[2]] ## EucO
# hydroweight_test[[3]] ## FLO 
# hydroweight_test[[4]] ## HAFLO 
# hydroweight_test[[5]] ## EucS
# hydroweight_test[[6]] ## FLS  
# hydroweight_test[[7]] ## HAFLS

## Plot different weighting schemes; where purple --> yellow == low --> high weight
par(mfrow=c(2,4), mar=c(1,1,1,1), oma = c(0,0,0,0))
layout(matrix(c(1, 2, 3, 4,
                1, 5, 6, 7), nrow = 2, byrow = TRUE))
plot(hydroweight_test[[1]], main="Lumped", axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[2]], main="EucO", axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[3]], main="FLO", axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(log(hydroweight_test[[4]]), main="HAFLO", axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot.new()
plot(hydroweight_test[[5]], main="EucS", axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(hydroweight_test[[6]], main="FLS", axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(log(hydroweight_test[[7]]), main="HAFLS", axes=F, legend=F, box = FALSE, col=viridis::viridis(101))

```

Important things to note from this plot: 

* lumped_inv is equal weighting where all values = 1 
* EucO_inv extents outward to the extent of the DEM
* FLO only includes areas draining to target_O
* EucS and FLS include those areas draining to all streams (i.e., target_S)
* HAFLO and HAFLS were log transformed to visualize the result. 
* For FLO/HAFLO/FLS/HAFLS, only those cells contributing to the areas of interest are calculated
* As in Peterson *et al.* (2011), for HAFLO and HAFLS, the targets are set to NoData (i.e., NA) since they likely represent concentrated flow areas. 

The temporary files made per instance of `hydroweight::hydroweight()`:

```{r}
list.files(hydroweight_dir)[grep("TEMP-", list.files(hydroweight_dir))]
```

A few options to consider: 

```{r, fig.width = 7, fig.height = 7, message = FALSE, error = FALSE}
## Setting a clip region, see ?hydroweight 
hydroweight_test_clip <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O,
  target_S = tg_S,
  OS_combine = TRUE, 
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO",
                       "EucS", "FLS", "HAFLS"),
  inv_function = myinv,
  roi_uid = "1"
)

## Resultant structure:
# length(hydroweight_test_clip) ## 1 set of targets and 7 distance-weighted rasters
# hydroweight_test_clip[[1]] ## lumped
# hydroweight_test_clip[[2]] ## EucO
# hydroweight_test_clip[[3]] ## FLO 
# hydroweight_test_clip[[4]] ## HAFLO 
# hydroweight_test_clip[[5]] ## EucS
# hydroweight_test_clip[[6]] ## FLS  
# hydroweight_test_clip[[7]] ## HAFLS

plot(hydroweight_test_clip[[2]], main="EucO - 8000 m clip", axes=F, legend=F, box = FALSE, col=viridis::viridis(101))

## Ignoring target_O
hydroweight_test_no_O <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_S = tg_S,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("EucS", "FLS", "HAFLS"),
  inv_function = myinv,
  roi_uid = "1"
)

## Resultant structure:
# length(hydroweight_test_no_O) ## 1 set of targets and 3 distance-weighted rasters
# hydroweight_test_no_O[[1]] ## EucS
# hydroweight_test_no_O[[2]] ## FLS
# hydroweight_test_no_O[[3]] ## HAFLS 

## Ignoring target_S
hydroweight_test_no_S <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("EucO", "FLO", "HAFLO"),
  inv_function = myinv,
  roi_uid = "1"
)

## Resultant structure:
# length(hydroweight_test_no_O) ## 1 set of targets and 3 distance-weighted rasters
# hydroweight_test_no_O[[1]] ## EucO
# hydroweight_test_no_O[[2]] ## FLO
# hydroweight_test_no_O[[3]] ## HAFLO 
```

### 3.4 Running `hydroweight()` across a set of sites

We wanted users an opportunity to access/investigate processed data as much as possible. 
For simplicity, we wanted only two functions that could fit within `for`-, `foreach`-, 
or `lapply`-like sequences when users are interested in calculating distance-weighted 
landscape statistics across many sites.

For implementing `hydroweight()` across many sites, we advocate the use of 
`foreach` since it is `lapply`-like and can pass on and over any errors 
for later fixing. Linking `foreach` with `doParallel` allows for parallel processing 
(e.g., `foreach(...) %dopar%`) but we have not tested `whitebox` using parallel 
processing (we suspect potentially big problems and burnt computers but we are not computer scientists). 

Additionally, `hydroweight()` exports an `.rds` of its result to `hydroweight_dir`. This 
allows users to assign the results of `hydroweight()` to an object in the current 
environment or to run `hydroweight()` alone and upload the `.rds` afterwards. See below. 


```{r, message = FALSE, error = FALSE}
## Generate column for unique id, put 5 instances in a list, bind together, 
## and assign unique identifiers - these are our new "sites"
tg_O$id <- 1
tg_O_x5 <- list(tg_O, tg_O, tg_O, tg_O, tg_O)
tg_O_x5 <- do.call(dplyr::bind_rows, tg_O_x5)  
tg_O_x5$id <- seq(1:5)  

## Use foreach() but could use lapply() as well.
hydroweight_test_x5 <- foreach(x = 1:5, .errorhandling = "pass") %do% {
  
  message("Running hydroweight for site ", x, " at ", Sys.time())
  
  hydroweight_test <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O_x5[x,],                      ### the important piece to change
  target_S = tg_S,
  OS_combine = TRUE,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO",
                       "EucS", "FLS", "HAFLS"),
  inv_function = myinv,
  roi_uid = tg_O_x5$id[x]                          ### the important piece to change
  )

  return(hydroweight_test)
}  

## Resultant structure: 
## length(hydroweight_test_x5) # 5 sites 
## length(hydroweight_test_x5[[1]]) # 7 distance-weighted rasters for each site
## hydroweight_test_x5[[1]][[1]] # site 1, lumped
## hydroweight_test_x5[[1]][[2]] # site 1, EucO
## hydroweight_test_x5[[1]][[3]] # site 1, FLO
## hydroweight_test_x5[[1]][[4]] # site 1, HAFLO
## hydroweight_test_x5[[1]][[5]] # site 1, EucS
## hydroweight_test_x5[[1]][[6]] # site 1, FLS
## hydroweight_test_x5[[1]][[7]] # site 1, HAFLS 
## ... 
## ... 
## ...
## hydroweight_test_x5[[5]][[7]] # site 5, HAFLS

## Loading up data after if didn't assign as an object while running
hydroweight_dir_files <- list.files(hydroweight_dir, full.names = TRUE)
hydroweight_test_x5 <- hydroweight_dir_files[grep("_inv_distances.rds", hydroweight_dir_files)]
hydroweight_test_x5
hydroweight_test_x5 <- lapply(hydroweight_test_x5, function(x) { readRDS(x) })

## Resultant structure: 
## length(hydroweight_test_x5) # 5 sites 
## length(hydroweight_test_x5[[1]]) # 7 distance-weighted rasters for each site
## hydroweight_test_x5[[1]][[1]] # site 1, lumped
## hydroweight_test_x5[[1]][[2]] # site 1, EucO
## hydroweight_test_x5[[1]][[3]] # site 1, FLO
## hydroweight_test_x5[[1]][[4]] # site 1, HAFLO
## hydroweight_test_x5[[1]][[5]] # site 1, EucS
## hydroweight_test_x5[[1]][[6]] # site 1, FLS
## hydroweight_test_x5[[1]][[7]] # site 1, HAFLS 
## ... 
## ... 
## ...
## hydroweight_test_x5[[5]][[7]] # site 5, HAFLS
```

## 4.0 Generate inverse distance-weighted attributes using `hydroweight_attributes()`

`hydroweight_attributes()` calculates distance-weighted attributes using 
distance-weighted rasters generated in `hydroweight()`, a region of interest
(`roi`, e.g., a catchment polygon), and an attribute layer (`loi`, e.g., land 
use raster/polygon). The function outputs an attribute summary table or a list 
that includes the summary table and layers used for calculation. Summary statistics 
are calculated as in Peterson *et al.* (2011). 

IMPORTANTLY, this function only produces one instance of the layer x weight summary 
statistics (i.e., one `roi`, one `loi`, and one `distance_weight`). 
A workflow is provided below to include more targets and layers.

Applying the same approach as above (i.e., using `foreach()`), we can generate 
distance-weighted attributes for a single site across all of our distance-weighted rasters.
Remember that we clipped the distance-weighted rasters by 8000 m in the plots below.

### 4.1 Generate catchment for lake  

```{r, fig.width = 7, fig.height = 7, message = FALSE, error = FALSE}
## Generate catchment for lake 
tg_O_r <- toy_dem<220
tg_O_r[tg_O_r@data@values != 1] <- NA

writeRaster(tg_O_r, file.path(hydroweight_dir, "tg_O_r.tif"), overwrite = TRUE)

wbt_watershed(
  d8_pntr = file.path(hydroweight_dir, "toy_dem_breached_d8.tif"),
  pour_pts = file.path(hydroweight_dir, "tg_O_r.tif"), 
  output = file.path(hydroweight_dir, "tg_O_r_catchment.tif"))

tg_O_catchment <- raster(file.path(hydroweight_dir, "tg_O_r_catchment.tif"))
tg_O_catchment <- rasterToPolygons(tg_O_catchment, dissolve = T)
tg_O_catchment <- st_as_sf(tg_O_catchment)

## Plot 
plot(hydroweight_test[[2]], axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(st_geometry(tg_O_catchment),  col = adjustcolor("grey", alpha.f = 0.5), add=T)
plot(tg_O, col="red", add = T, legend = FALSE)
plot(tg_S, col="blue", add = T, legend = FALSE)
legend("bottom", legend = c("target_O = tg_O", "target_S = tg_S", "catchment"), fill = c("red", "blue", adjustcolor("grey", alpha.f = 0.5)), horiz = TRUE, bty = "n" )

```
### 4.1 Using a numeric raster layer of interest 

```{r, fig.width = 7, fig.height = 7, message = FALSE, error = FALSE}
## Construct continuous dataset
ndvi <- tg_O_r 
ndvi@data@values <- runif(n = (ndvi@ncols * ndvi@nrows), min = 0, max = 1)
names(ndvi) <- "ndvi"

## Plot 
plot(ndvi, axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(st_geometry(tg_O_catchment),  col = adjustcolor("grey", alpha.f = 0.5), add=T)
plot(tg_O, col="red", add = T, legend = FALSE)
plot(tg_S, col="blue", add = T, legend = FALSE)
legend("bottom", legend = c("target_O = tg_O", "target_S = tg_S", "catchment"), fill = c("red", "blue", adjustcolor("grey", alpha.f = 0.5)), horiz = TRUE, bty = "n" )

## For each distance weight from hydroweight_test above, calculate the landscape statistics for ndvi
hydroweight_attribute_test_numeric <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {

  test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
                                               loi = ndvi, 
                                               loi_numeric = TRUE, 
                                               distance_weight = hydroweight_test[[x]], ## Important to change
                                               remove_region = tg_O, 
                                               resample = "bilinear", 
                                               return_products = TRUE, 
                                               roi_uid = "1",
                                               roi_uid_col = "site",
                                               loi_attr_col = "ndvi")

return(test_numericraster)
}


## Resultant structure: 
## length(hydroweight_attribute_test_numeric) # Attributes and processing components for 7 inputted distance-weighted rasters 
## hydroweight_attribute_test_numeric[[1]][[1]] # Attributes calculated for lumped attribute statistics
## hydroweight_attribute_test_numeric[[1]][[2]] # processed loi used in calculating lumped attribute statistics 
## hydroweight_attribute_test_numeric[[1]][[3]] # processed distance-weighted raster used in calculating lumped attribute statistics 
## ... 
## ... 
## ... 
## hydroweight_attribute_test_numeric[[7]][[3]] # processed distance-weighted raster used in calculating HAFLS attribute statistics 

## For each distance-weighted raster input, extract results and apply name changes to specify distance-weighting name used
results <- foreach(x = 1:length(hydroweight_attribute_test_numeric), .errorhandling = "pass") %do% { 
  
  ## Get names of distance-weighted rasters from hydroweight_test
  (names_hwtn <- names(hydroweight_test)[x]) 
  
  ## Paste distance-weighted raster name together with attribute column names except "site" from above
  (names_hwtn <- paste0(names_hwtn, "_", colnames(hydroweight_attribute_test_numeric[[x]][[1]])[-1]))
  
  ## Assign column names 
  colnames(hydroweight_attribute_test_numeric[[x]][[1]])[-1] <- names_hwtn
 
   return(hydroweight_attribute_test_numeric[[x]])
  
}

## Extract only the summary table and bind results, see names of dataframe
results_agg <- lapply(results, function(x){x[[1]]})
results_agg <- Reduce(merge, results_agg) 
names(results_agg)
``` 

```{r, fig.width=7, fig.height=14, message = FALSE, error = FALSE}
## Plot results
par(mfrow=c(3,2), mar=c(1,1,1,1), oma = c(0,0,0,0))

## Lumped 
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - loi")
plot(results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col="yellow", add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - loi * distance_weight")
plot(results[[1]]$`loi_Raster*_bounded` * results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)

## EucO
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi")
plot(results[[2]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi * distance_weight")
plot(results[[2]]$`loi_Raster*_bounded` * results[[2]]$distance_weight_bounded, main="Lumped \n- loi * distance_weight", axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)

## FLO 
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi")
plot(results[[3]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi * distance_weight")
plot(results[[3]]$`loi_Raster*_bounded` * results[[3]]$distance_weight_bounded, main="Lumped \n- loi * distance_weight", axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
```

### 4.2 Using a categorical raster layer of interest 

```{r, fig.width=7, fig.height=7, message = FALSE, error = FALSE}
## Construct categorical dataset by reclassify elevation values into categories
lulc <- toy_dem
m <- c(0, 220, 1, 220, 300, 2, 300, 400, 3, 400, Inf, 4)
rclmat <- matrix(m, ncol = 3, byrow = TRUE)
lulc <- reclassify(lulc, rclmat)

## Plot 
plot(lulc, axes=F, legend=F, box = FALSE, col=viridis::viridis(101))
plot(st_geometry(tg_O_catchment),  col = adjustcolor("grey", alpha.f = 0.5), add=T)
plot(tg_O, col="red", add = T, legend = FALSE)
plot(tg_S, col="blue", add = T, legend = FALSE)
legend("bottom", legend = c("target_O = tg_O", "target_S = tg_S", "catchment"), fill = c("red", "blue", adjustcolor("grey", alpha.f = 0.5)), horiz = TRUE, bty = "n" )

## Run hydroweight attributes
hydroweight_attribute_test_categorical <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
  
  test_categoricalraster <- hydroweight_attributes(roi = tg_O_catchment,
                                               loi = lulc, 
                                               loi_numeric = FALSE, 
                                               distance_weight = hydroweight_test[[x]], # Important to change
                                               remove_region = tg_O, 
                                               resample = "ngb", 
                                               return_products = TRUE, 
                                               roi_uid = "1",
                                               roi_uid_col = "site",
                                               loi_attr_col = "lulc", 
                                               )
}

## Resultant structure: 
## length(hydroweight_attribute_test_categorical) # Attributes and processing components for 7 inputted distance-weighted rasters 
## hydroweight_attribute_test_categorical[[1]][[1]] # Attributes calculated for lumped attribute statistics
## hydroweight_attribute_test_categorical[[1]][[2]][[1]] # processed loi used in calculating lumped attribute statistics, RasterLayer category 4 
## hydroweight_attribute_test_categorical[[1]][[2]][[2]] # processed loi used in calculating lumped attribute statistics, RasterLayer category 3 
## hydroweight_attribute_test_categorical[[1]][[2]][[3]] # processed loi used in calculating lumped attribute statistics, RasterLayer category 2 
## hydroweight_attribute_test_categorical[[1]][[3]] # processed distance-weighted raster used in calculating lumped attribute statistics 
## ... 
## ... 
## ... 
## hydroweight_attribute_test_categorical[[7]][[3]] # processed distance-weighted raster used in calculating HAFLS attribute statistics 

## For each distance-weighted raster input, extract results and apply name changes to specify distance-weighting name used
results <- foreach(x = 1:length(hydroweight_attribute_test_categorical), .errorhandling = "pass") %do% { 
  
  ## Get names of distance-weighted rasters from hydroweight_test
  (names_hwtn <- names(hydroweight_test)[x]) 
  
  ## Paste distance-weighted raster name together with attribute column names except "site" from above
  (names_hwtn <- paste0(names_hwtn, "_", colnames(hydroweight_attribute_test_categorical[[x]][[1]])[-1]))
  
  ## Assign column names 
  colnames(hydroweight_attribute_test_categorical[[x]][[1]])[-1] <- names_hwtn
 
   return(hydroweight_attribute_test_categorical[[x]])
  
}

## Extract only the summary table and bind results, see names of dataframe
results_agg <- lapply(results, function(x){x[[1]]})
results_agg <- Reduce(merge, results_agg) 
names(results_agg)
```

```{r, fig.height = 7, fig.width = 14, message = FALSE, error = FALSE} 
## Plot results
par(mfrow=c(3,4), mar=c(1,1,1,1), oma = c(0,0,0,0), cex = 0.75)

## Lumped 
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped")
plot(results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col="yellow", add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - loi * lulc (cat: 4)")
plot(results[[1]][[2]][[1]]* results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - loi * lulc (cat: 3)")
plot(results[[1]][[2]][[2]]* results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "Lumped - loi * lulc (cat: 2)")
plot(results[[1]][[2]][[3]]* results[[1]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)

## EucO
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO")
plot(results[[2]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi * lulc (cat: 4)")
plot(results[[2]][[2]][[1]]* results[[2]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi * lulc (cat: 3)")
plot(results[[2]][[2]][[2]]* results[[2]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "EucO - loi * lulc (cat: 2)")
plot(results[[2]][[2]][[3]]* results[[2]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)

## FLO
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO")
plot(results[[3]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi * lulc (cat: 4)")
plot(results[[3]][[2]][[1]]* results[[3]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi * lulc (cat: 3)")
plot(results[[3]][[2]][[2]]* results[[3]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
plot(st_as_sfc(st_bbox(tg_O_catchment)), border = "white", main = "FLO - loi * lulc (cat: 2)")
plot(results[[3]][[2]][[3]]* results[[3]]$distance_weight_bounded, axes=F, legend=F, box = FALSE, col=viridis::viridis(101), add = TRUE)
```

### 4.3 Using a polygon layer of interest with numeric data in the column 

```{r, fig.height = 7, fig.width = 14, message = FALSE, error = FALSE}
## Construct polygons with numeric data by converting lulc to polygons and assigning values to columns 
lulc_p <- rasterToPolygons(lulc, dissolve = T, na.rm = T)
lulc_p <- st_as_sf(lulc_p)

lulc_p$var_1 <- runif(n = 4, min = 0, max = 10)
lulc_p$var_2 <- runif(n = 4, min = 0, max = 1)

hydroweight_attribute_test_numeric_polygon <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
  
  test_categoricalraster <- hydroweight_attributes(roi = tg_O_catchment,
                                               loi = lulc_p, 
                                               loi_numeric = TRUE, 
                                               loi_categories = c("var_1", "var_2"),
                                               distance_weight = hydroweight_test[[x]], # Important to change
                                               remove_region = tg_O, 
                                               resample = "ngb", 
                                               return_products = TRUE, 
                                               roi_uid = "1",
                                               roi_uid_col = "site",
                                               loi_attr_col = "lulc" 
                                               )
}

## Resultant structure: 
# length(hydroweight_attribute_test_numeric_polygon) # Attributes and processing components for 7 inputted distance-weighted rasters 
# hydroweight_attribute_test_numeric_polygon[[1]][[1]] # Attributes calculated for lumped attribute statistics
# hydroweight_attribute_test_numeric_polygon[[1]][[2]][[1]] # processed loi used in calculating lumped attribute statistics, RasterLayer representing var_1
# hydroweight_attribute_test_numeric_polygon[[1]][[2]][[2]] # processed loi used in calculating lumped attribute statistics, RasterLayer representing var_2 
# hydroweight_attribute_test_numeric_polygon[[1]][[3]] # processed distance-weighted raster used in calculating lumped attribute statistics 
# ... 
# ... 
# ... 
# hydroweight_attribute_test_numeric_polygon[[7]][[3]] # processed distance-weighted raster used in calculating HAFLS attribute statistics 

## For each distance-weighted raster input, extract results and apply name changes to specify distance-weighting name used
results <- foreach(x = 1:length(hydroweight_attribute_test_numeric_polygon), .errorhandling = "pass") %do% { 
  
  ## Get names of distance-weighted rasters from hydroweight_test
  (names_hwtn <- names(hydroweight_test)[x]) 
  
  ## Paste distance-weighted raster name together with attribute column names except "site" from above
  (names_hwtn <- paste0(names_hwtn, "_", colnames(hydroweight_attribute_test_numeric_polygon[[x]][[1]])[-1]))
  
  ## Assign column names 
  colnames(hydroweight_attribute_test_numeric_polygon[[x]][[1]])[-1] <- names_hwtn
 
   return(hydroweight_attribute_test_numeric_polygon[[x]])
  
}

## Extract only the summary table and bind results, see names of dataframe
results_agg <- lapply(results, function(x){x[[1]]})
results_agg <- Reduce(merge, results_agg) 
names(results_agg)
```

### 4.4 Using a polygon layer of interest with categorical data in the column 

```{r, message = FALSE, error = FALSE}
## Construct polygons with categorical data by converting lulc to polygons and assigning values to columns 
lulc_p <- rasterToPolygons(lulc, dissolve = T, na.rm = T)
lulc_p <- st_as_sf(lulc_p)

lulc_p$var_1 <- sample(c(1:10), size = 4, replace = TRUE)
lulc_p$var_2 <- sample(c(20:30), size = 4, replace = TRUE)

hydroweight_attribute_test_categorical_polygon <- foreach(x = 1:length(hydroweight_test), .errorhandling = "pass") %do% {
  
  test_categoricalraster <- hydroweight_attributes(roi = tg_O_catchment,
                                               loi = lulc_p,                            # Important to change
                                               loi_numeric = FALSE,                     # Important to change
                                               loi_categories = c("var_1", "var_2"),
                                               distance_weight = hydroweight_test[[x]], # Important to change
                                               remove_region = tg_O, 
                                               resample = "ngb", 
                                               return_products = TRUE, 
                                               roi_uid = "1",
                                               roi_uid_col = "site",
                                               loi_attr_col = "lulc" 
                                               )
}

## Resultant structure: 
# length(hydroweight_attribute_test_categorical_polygon) # Attributes and processing components for 7 inputted distance-weighted rasters 
# hydroweight_attribute_test_categorical_polygon[[1]][[1]] # Attributes calculated for lumped attribute statistics
# hydroweight_attribute_test_categorical_polygon[[1]][[2]][[1]] # processed loi used in calculating lumped attribute statistics, RasterLayer representing var_1
# hydroweight_attribute_test_categorical_polygon[[1]][[2]][[2]] # processed loi used in calculating lumped attribute statistics, RasterLayer representing var_2 
# hydroweight_attribute_test_categorical_polygon[[1]][[3]] # processed distance-weighted raster used in calculating lumped attribute statistics 
# ... 
# ... 
# ... 
# hydroweight_attribute_test_categorical_polygon[[7]][[3]] # processed distance-weighted raster used in calculating HAFLS attribute statistics 

## For each distance-weighted raster input, extract results and apply name changes to specify distance-weighting name used
results <- foreach(x = 1:length(hydroweight_attribute_test_categorical_polygon), .errorhandling = "pass") %do% { 
  
  ## Get names of distance-weighted rasters from hydroweight_test
  (names_hwtn <- names(hydroweight_test)[x]) 
  
  ## Paste distance-weighted raster name together with attribute column names except "site" from above
  (names_hwtn <- paste0(names_hwtn, "_", colnames(hydroweight_attribute_test_categorical_polygon[[x]][[1]])[-1]))
  
  ## Assign column names 
  colnames(hydroweight_attribute_test_categorical_polygon[[x]][[1]])[-1] <- names_hwtn
 
   return(hydroweight_attribute_test_categorical_polygon[[x]])
  
}

## Extract only the summary table and bind results, see names of dataframe
results_agg <- lapply(results, function(x){x[[1]]})
results_agg <- Reduce(merge, results_agg) 
names(results_agg)
```
### 4.5 Bringing it all together: Running hydroweight() and hydroweight_attributes() across sites and layers

By setting up a `do.call()` using a list of parameters, both functions can be 
run across. 

```{r}

## Sites 
tg_O_x5

## Generate catchments
tg_O_catchment$id <- 1
tg_O_catchment_x5 <- list(tg_O_catchment, tg_O_catchment, tg_O_catchment, tg_O_catchment, tg_O_catchment)
tg_O_catchment_x5 <- do.call(dplyr::bind_rows, tg_O_catchment_x5)  
tg_O_catchment_x5$id <- seq(1:5)  

tg_O_catchment_x5

## Set up a series of the layers to iterate over sites (indexed `xx` below) and layers (indexed 'yy' below)
ndvi
lulc
lulc_p

?hydroweight_attributes

# the consistent pieces
layers_consist <- list(roi = tg_O_catchment_x5[xx,]
                       distance_weight = sites_weights[[yy]], 
                       remove_region = tg_O_x5[xx,], 
                       return_products = TRUE, 
                       roi_uid_col = "site", 
                       
                       



## Generate list of layer_call where each element of the list is a hydroweight_attribute() call 
foreach(xx = 1:5, .errorhandling = "pass") %do% {
  
  site_weights <- hydroweight::hydroweight(
    hydroweight_dir = hydroweight_dir,
    target_O = tg_O_x5[xx,], 
    roi_uid = tg_O_x5$id[xx], # important to change
    target_S = tg_S,
    OS_combine = TRUE,
    dem = "toy_dem_breached.tif", 
    dem_crs = crs(toy_dem), 
    flow_accum = "toy_dem_breached_accum.tif", 
    weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO", "EucS", "FLS", "HAFLS"), 
    inv_function = myinv,
    ) 

  layers_consist <- list(roi = tg_O_catchment[xx,],
                       distance_weight = sites_weights[[yy]], 
                       remove_region = tg_O, 
                       return_products = TRUE,
                       roi_uid_col = "site") 
  
  

  
      
  
  
  
    
    
}
  
  
  
  sites_call <- list(
    
  
    
    
  sites_weights <- do.call(hydroweight, sites_call)
  
  
  
  
  
}



## Generate an iterative site_call, where site index is `xx`




this <- list("see", "this", "here")
this2 <- list("see")

c(this, this2)

sites_call

do.call(hydroweight, sites_call) 
do.call(hydroweight_attributes, layers_call)


## 
layer_1 <- list(roi = 
                loi = ndvi, 
                
                loi_numeric = TRUE, 
                )
  


  
  resample = "ngb", 
                       
  
roi = tg_O_catchment,
                                               loi = lulc_p,                            # Important to change
                                               loi_numeric = FALSE,                     # Important to change
                                               loi_categories = c("var_1", "var_2"),
                                                
                                               )  
  
  
  
  
sites_unique


layer_consist <- 

  
  lapply(1:nrow(tg_O_x5), function(x){tg_O_x5})


?split


sites_change <- list(target_O = )



```
## Setup call for sites 


 hydroweight_test <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O_x5[x,],                      ### the important piece to change
  target_S = tg_S,
  
  roi_uid = tg_O_x5$id[x]



## Setup calls for layers 
## Clean up layer names 
## Export up by combining 


## Unique sites 

## Unique layers 


foreach(sites) 

  unique sites + basic setup 
  
  foreach(layers) 
  
  unique layers + basic setup


foreach site, weights 
foreach site, attributes


sites <- 
roi_uids <- 





list(sites) 
list(parameters) 


list(roi = tg_O_catchment, 
loi = lulc_p, loi_numeric = FALSE, loi_categories = c("var_1", "var_2"),
distance_weight = hydroweight_test[[x]], # Important to change
remove_region = tg_O, 
resample = "ngb", 
return_products = TRUE, 
                                               roi_uid = "1",
                                               roi_uid_col = "site",
                                               loi_attr_col = "lulc" 


lapply()

?foreach



lulc_r_numeric
lulc_r_categorical
lulc_p_numeric 
lulc_p_categorical


hydroweight_test_x5_attributes <- foreach(x = 1:5, .errorhandling = "pass") %do {
  
  ## For each site 
  
  ## For each layer 
  
  loi_1 <- 
  
  
  ## For each site, 
  
  ## For each layer, 
  loi_1
  
  
  
  
  
  
  
  
}




## Use foreach() but could use lapply() as well.
hydroweight_test_x5 <- foreach(x = 1:5, .errorhandling = "pass") %do% {
  
  message("Running hydroweight for site ", x, " at ", Sys.time())
  
  hydroweight_test <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O_x5[x,],                      ### the important piece to change
  target_S = tg_S,
  OS_combine = TRUE,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("lumped", "EucO", "FLO", "HAFLO",
                       "EucS", "FLS", "HAFLS"),
  inv_function = myinv,
  roi_uid = tg_O_x5$id[x]                          ### the important piece to change
  )

  return(hydroweight_test)
} 














### 4.6 Running hydroweight_attributes() across a sequence of sites and layers of interest

## 5.0 References

Kielstra, B. W., Chau, J., & Richardson, J. S. (2019). Measuring function and structure of urban headwater streams with citizen scientists. Ecosphere, 10(4):e02720. https://doi.org/10.1002/ecs2.2720

Lindsay J.B. (2016). Whitebox GAT: A case study in geomorphometric analysis. Computers & Geosciences, 95: 75-84. https://doi.org/10.1016/j.cageo.2016.07.003

Peterson, E. E., Sheldon, F., Darnell, R., Bunn, S. E., & Harch, B. D. (2011). A comparison of spatially explicit landscape representation methods and their relationship to stream condition. Freshwater Biology, 56(3), 590–610. https://doi.org/10.1111/j.1365-2427.2010.02507.x

Peterson, E. E. & Pearse, A. R. (2017). IDW‐Plus: An ArcGIS Toolset for calculating spatially explicit watershed attributes for survey sites. 
Journal of the American Water Resources Association, 53(5): 1241–1249. https://doi.org/10.1111/1752-1688.12558 

Pearse A., Heron G., & Peterson E. (2019). rdwplus: An Implementation of IDW-PLUS. R package version 0.1.0. https://CRAN.R-project.org/package=rdwplus

Wu Q. (2020). whitebox: 'WhiteboxTools' R Frontend. R package version 1.4.0. https://github.com/giswqs/whiteboxR



## Construct a toy raster and polygon dataset 
lulc <- ndvi
lulc@data@values <- sample(c(1,2,3), size = length(lulc@data@values), replace = TRUE)
lulc_p <- raster::rasterToPolygons(lulc)

hist(lulc@data@values)
plot(lulc)
plot(lulc_p)

# ## 1) Construct a toy dataset ----
# 
# NC_lkscapes <- lkscape_ih[lkscape_ih_bsm]
# length(NC_lkscapes)
# 
# ## boundary 
# b <- st_union((NC_lkscapes[[2]][[3]]))
# b <- st_as_sf(b)
# plot(b)
# 
# ## land cover classes polygon
# lulc <- NC_lkscapes[[2]][[3]]
# lulc$ulc <- sample(c(100, 200, 300), size = 10, replace=T)
# lulc$grad_1 <- lulc$ulc 
# lulc$grad_2 <- lulc$ulc^2 * 0.75
# st_area(lulc)/st_area(b) # 74% and 0.008%
# 
# plot(b, col="lightgrey", border="lightgrey")
# plot(lulc["ulc"], add=T)
# plot(lulc["grad_1"], add=T)
# plot(lulc["grad_2"], add=T)
# 
# ## continuous
# ndvi <- dw
# (ndvi@data@values <- rnorm(n = length(ndvi@data@values), mean = 0, sd = 0.25))
# names(ndvi) <- "ndvi"
# 
# ## remove region (i.e., not included in calculation) 
# lake <- NC_lkscapes[[2]][[1]]
# plot(st_geometry(lake), add=T, col="lightblue")
# 
# ## distance_weight
# dw <- lkscape_ih_hydrology[[2]][[1]]
# 
# ## Real example, raster ---- 
# plot(ndvi)
# plot(b, add=T)
# 
# test_realraster <- hydroweight_attributes(boundary = b,
#                                           remove_region = lake,
#                                           distance_weight = dw,
#                                           layer = ndvi,
#                                           real = TRUE, 
#                                           resample = "bilinear", 
#                                           return_products = TRUE
# )
# test_realraster
# par(mfrow=c(1,3))
# plot(test_realraster[[2]], axes=F, legend=F, main = "data")
# plot(test_realraster[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(test_realraster[[2]] * test_realraster[[3]], main = "data * distance_weighting")
# 
# ## Real example, raster unweighted ----
# test_realraster_uw <- hydroweight_attributes(boundary = b,
#                                              remove_region = lake,
#                                              distance_weight = dw>0,
#                                              layer = ndvi,
#                                              real = TRUE, 
#                                              resample = "bilinear", 
#                                              return_products = TRUE
# )
# 
# viz <- test_realraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# 
# ## Categorical Example, raster weighted----
# lulc_rast <- fasterize::fasterize(lulc, raster = dw, 
#                                   field = "ulc")
# plot(lulc_rast)
# 
# test_categoricalraster <- hydroweight_attributes(boundary = b,
#                                                  remove_region = lake,
#                                                  distance_weight = dw,
#                                                  categories = NULL,
#                                                  layer = lulc_rast,
#                                                  real = FALSE, 
#                                                  resample = "ngb", 
#                                                  return_products = TRUE
# )
# 
# viz <- test_categoricalraster
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]])
# viz[[1]]
# 
# test_categoricalraster_uw <- hydroweight_attributes(boundary = b,
#                                                     remove_region = lake,
#                                                     distance_weight = dw>0,
#                                                     categories = NULL,
#                                                     layer = lulc_rast,
#                                                     real = FALSE, 
#                                                     resample = "ngb", 
#                                                     return_products = TRUE
# )
# 
# viz <- test_categoricalraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]]) # should be summing to 1
# viz[[1]]
# 
# ## Real example, from polygon column ----
# 
# test_realpolygon <- hydroweight_attributes(boundary = b,
#                                            remove_region = lake,
#                                            distance_weight = dw,
#                                            categories = c("grad_1", "grad_2"),
#                                            layer = lulc,
#                                            real = TRUE, 
#                                            resample = "ngb", 
#                                            return_products = TRUE
# )
# 
# viz <- test_realpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_realpolygon_uw <- hydroweight_attributes(boundary = b,
#                                               remove_region = lake,
#                                               distance_weight = dw>0,
#                                               categories = c("grad_1", "grad_2"),
#                                               layer = lulc,
#                                               real = TRUE, 
#                                               resample = "ngb", 
#                                               return_products = TRUE
# )
# 
# viz <- test_realpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## Categorical example, from polygon column ----
# 
# test_categoricalpolygon <- hydroweight_attributes(boundary = b,
#                                                   remove_region = lake,
#                                                   distance_weight = dw,
#                                                   categories = c("grad_1", "grad_2"),
#                                                   layer = lulc,
#                                                   real = FALSE, 
#                                                   resample = "bilinear", 
#                                                   return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_categoricalpolygon_uw <- hydroweight_attributes(boundary = b,
#                                                      remove_region = lake,
#                                                      distance_weight = dw>0,
#                                                      categories = c("grad_1", "grad_2"),
#                                                      layer = lulc,
#                                                      real = FALSE, 
#                                                      resample = "bilinear", 
#                                                      return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 



```




# ## ***********************
# ## TEST - HYDROWEIGHT ----
# ## *********************** 
# 
 
# ## Write toy_dem and run some processing through whitebox
# raster::writeRaster(toy_dem, 
#                     file.path(hydroweight_dir, "toy_dem.tif"), overwrite = T)
# 
# wbt_breach_depressions(file.path(hydroweight_dir, "toy_dem.tif"), 
#                        file.path(hydroweight_dir, "toy_dem_breached.tif"))
# 
# wbt_d_inf_flow_accumulation(file.path(hydroweight_dir, "toy_dem_breached.tif"), 
#                             file.path(hydroweight_dir, "toy_dem_breached_accum.tif"), 
#                             out_type = "cells")
# 
# wbt_extract_streams(file.path(hydroweight_dir, "toy_dem_breached_accum.tif"), 
#                     file.path(hydroweight_dir, "toy_dem_streams.tif"),
#                     threshold = 2000)
# 
# ## For hydroweight, there are target_O and target_S 
# ## target_O is a target point or location for calculating distances 
# ## target_S is a stream/waterbody target for calculating distances 
# 
# ## Generate target_0
# tg <- toy_dem<220
# tg[tg@data@values != 1] <- NA
# tg <- raster::rasterToPolygons(tg, dissolve=T)
# tg <- sf::st_as_sf(tg)
# 
# plot(toy_dem)
# plot(tg, col="red", add=T)
# plot(streams, col="blue", add=T)
# 
# hydroweight_test <- hydroweight(
#   hydroweight_dir = "./out_spatial/hydroweight_output", 
#   target_O = tg, 
#   target_S = "toy_dem_streams.tif", 
#   target_OS = TRUE,
#   clip_region = 8000,
#   dem = "toy_dem_breached.tif", 
#   flow_accum = "toy_dem_breached_accum.tif", 
#   weighting_scheme = c("iEucO", "iFLO", "HAiFLO", 
#                        "iEucS", "iFLS", "HAiFLS"), 
#   inv_function = function(x){ (x * 0.001 + 1)^-1 },
#   roi_uid = "1"
# )
# 
# par(mfrow=c(2,3), mar=c(1,1,3,1))
# plot(hydroweight_test[[1]], main=names(hydroweight_test)[1], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[2]], main=names(hydroweight_test)[2], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[3]], main=names(hydroweight_test)[3], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[4]], main=names(hydroweight_test)[4], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[5]], main=names(hydroweight_test)[5], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[6]], main=names(hydroweight_test)[6], axes=F, legend=F, col=viridis::viridis(10))

# ## **********************************
# ## TEST - HYDROWEIGHT_ATTRIBUTES ----
# ## ********************************** 
# 
# ## Construct toy watershed
# tg_shed <- st_buffer(tg, dist = 1000, endCapStyle = "SQUARE")
# hydroweight_extent <- st_as_sfc(st_bbox(extent(hydroweight_test[[1]])))
# st_crs(hydroweight_extent) <- st_crs(tg_shed)
# 
# tg_shed <- st_intersection(tg_shed, hydroweight_extent )
# 
# par(mfrow=c(1,1,))
# plot(hydroweight_test[[2]])
# plot(tg_shed, add=T)
# 
# ## Real example, raster ---- 
# 
# ## Construct continuous dataset 
# ndvi <- hydroweight_test[[1]]
# (ndvi@data@values <- runif(n = length(ndvi@data@values), min = 0, max = 1))
# 
# plot(ndvi)
# plot(tg_shed, add=T)
# 
# hydroweight_attribute_test_real <- lapply(hydroweight_test, function(hwr){
#   
#   test_realraster <- hydroweight_attributes(boundary = tg_shed,
#                                             remove_region = tg,
#                                             distance_weight = hwr,
#                                             layer = ndvi,
#                                             real = TRUE, 
#                                             resample = "bilinear", 
#                                             return_products = TRUE
#   )
#   
# })
# 
# results <- lapply(hydroweight_attribute_test_real, function(x){x[[1]]})
# results
# 
# 
# 
# ## 1) Construct a toy dataset ----
# 
# NC_lkscapes <- lkscape_ih[lkscape_ih_bsm]
# length(NC_lkscapes)
# 
# ## boundary 
# b <- st_union((NC_lkscapes[[2]][[3]]))
# b <- st_as_sf(b)
# plot(b)
# 
# ## land cover classes polygon
# lulc <- NC_lkscapes[[2]][[3]]
# lulc$ulc <- sample(c(100, 200, 300), size = 10, replace=T)
# lulc$grad_1 <- lulc$ulc 
# lulc$grad_2 <- lulc$ulc^2 * 0.75
# st_area(lulc)/st_area(b) # 74% and 0.008%
# 
# plot(b, col="lightgrey", border="lightgrey")
# plot(lulc["ulc"], add=T)
# plot(lulc["grad_1"], add=T)
# plot(lulc["grad_2"], add=T)
# 
# ## continuous
# ndvi <- dw
# (ndvi@data@values <- rnorm(n = length(ndvi@data@values), mean = 0, sd = 0.25))
# names(ndvi) <- "ndvi"
# 
# ## remove region (i.e., not included in calculation) 
# lake <- NC_lkscapes[[2]][[1]]
# plot(st_geometry(lake), add=T, col="lightblue")
# 
# ## distance_weight
# dw <- lkscape_ih_hydrology[[2]][[1]]
# 
# ## Real example, raster ---- 
# plot(ndvi)
# plot(b, add=T)
# 
# test_realraster <- hydroweight_attributes(boundary = b,
#                                           remove_region = lake,
#                                           distance_weight = dw,
#                                           layer = ndvi,
#                                           real = TRUE, 
#                                           resample = "bilinear", 
#                                           return_products = TRUE
# )
# test_realraster
# par(mfrow=c(1,3))
# plot(test_realraster[[2]], axes=F, legend=F, main = "data")
# plot(test_realraster[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(test_realraster[[2]] * test_realraster[[3]], main = "data * distance_weighting")
# 
# ## Real example, raster unweighted ----
# test_realraster_uw <- hydroweight_attributes(boundary = b,
#                                              remove_region = lake,
#                                              distance_weight = dw>0,
#                                              layer = ndvi,
#                                              real = TRUE, 
#                                              resample = "bilinear", 
#                                              return_products = TRUE
# )
# 
# viz <- test_realraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# 
# ## Categorical Example, raster weighted----
# lulc_rast <- fasterize::fasterize(lulc, raster = dw, 
#                                   field = "ulc")
# plot(lulc_rast)
# 
# test_categoricalraster <- hydroweight_attributes(boundary = b,
#                                                  remove_region = lake,
#                                                  distance_weight = dw,
#                                                  categories = NULL,
#                                                  layer = lulc_rast,
#                                                  real = FALSE, 
#                                                  resample = "ngb", 
#                                                  return_products = TRUE
# )
# 
# viz <- test_categoricalraster
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]])
# viz[[1]]
# 
# test_categoricalraster_uw <- hydroweight_attributes(boundary = b,
#                                                     remove_region = lake,
#                                                     distance_weight = dw>0,
#                                                     categories = NULL,
#                                                     layer = lulc_rast,
#                                                     real = FALSE, 
#                                                     resample = "ngb", 
#                                                     return_products = TRUE
# )
# 
# viz <- test_categoricalraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]]) # should be summing to 1
# viz[[1]]
# 
# ## Real example, from polygon column ----
# 
# test_realpolygon <- hydroweight_attributes(boundary = b,
#                                            remove_region = lake,
#                                            distance_weight = dw,
#                                            categories = c("grad_1", "grad_2"),
#                                            layer = lulc,
#                                            real = TRUE, 
#                                            resample = "ngb", 
#                                            return_products = TRUE
# )
# 
# viz <- test_realpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_realpolygon_uw <- hydroweight_attributes(boundary = b,
#                                               remove_region = lake,
#                                               distance_weight = dw>0,
#                                               categories = c("grad_1", "grad_2"),
#                                               layer = lulc,
#                                               real = TRUE, 
#                                               resample = "ngb", 
#                                               return_products = TRUE
# )
# 
# viz <- test_realpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## Categorical example, from polygon column ----
# 
# test_categoricalpolygon <- hydroweight_attributes(boundary = b,
#                                                   remove_region = lake,
#                                                   distance_weight = dw,
#                                                   categories = c("grad_1", "grad_2"),
#                                                   layer = lulc,
#                                                   real = FALSE, 
#                                                   resample = "bilinear", 
#                                                   return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_categoricalpolygon_uw <- hydroweight_attributes(boundary = b,
#                                                      remove_region = lake,
#                                                      distance_weight = dw>0,
#                                                      categories = c("grad_1", "grad_2"),
#                                                      layer = lulc,
#                                                      real = FALSE, 
#                                                      resample = "bilinear", 
#                                                      return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## ALL WORKS - OBVIOUSLY NEED BETTER EXAMPLES

# ## **********
## PLOTS ----
## ********** 

# ## 1) Distance weighted catchment influence ---- 
# 
# rescale_r <- function(x, x_min =NULL, x_max = NULL, new_min = 0, new_max = 1) {
#   if(is.null(x_min)) x_min = cellStats(x, min)
#   if(is.null(x_max)) x_max = cellStats(x, max)
#   new_min + (x - x_min) * ((new_max - new_min) / (x_max - x_min))
# }
# 
# ## Rasters to plot after running one instance of the loop
# iEucO_p <- hydroweight_attribute_test_real[[1]][[2]] * hydroweight_attribute_test_real[[1]][[3]]
# iFLO_p <- hydroweight_attribute_test_real[[2]][[2]] * hydroweight_attribute_test_real[[2]][[3]]
# HAiFLO_p <- hydroweight_attribute_test_real[[3]][[2]] * hydroweight_attribute_test_real[[3]][[3]]
# HAiFLO_p <- rescale_r(log(HAiFLO_p+1), new_min = 0, new_max = 1)
# iEucS_p <- hydroweight_attribute_test_real[[4]][[2]] * hydroweight_attribute_test_real[[4]][[3]]
# iFLS_p <- hydroweight_attribute_test_real[[5]][[2]] * hydroweight_attribute_test_real[[5]][[3]]
# HAiFLS_p <- hydroweight_attribute_test_real[[6]][[2]] * hydroweight_attribute_test_real[[6]][[3]]
# HAiFLS_p <- rescale_r(log(HAiFLS_p+1), new_min = 0, new_max = 1)
# 
# tiff(filename=paste0("./out_figs/", "Merc_DistanceWeightedCatchmentInfluence",
#                      Sys.Date(), ".tif"),
#      width=15, height=10, units="cm", res=300,
#      compression="lzw+p", type="cairo")
# 
# par(mfrow=c(2,3), oma=c(0,0,0,0), mar=c(0,0,2,0))
# plot(iEucO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iEucO")
# plot(tg_shed, add=T, col=NA, border="black")
# 
# plot(iFLO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iFLO")
# 
# plot(HAiFLO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "HA-iFLO")
# 
# plot(iEucS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iEucS")
# 
# plot(iFLS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iFLS")
# 
# plot(HAiFLS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "HA-iFLS")
# 
# dev.off()
# 
# hydroweight_attribute_test_real[[1]][[1]]


















