---
title: "hydroweight: Inverse distance-weighted rasters and attributes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hydroweight_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 1.0 Introduction

Environmental scientists often want to calculate landscape statistics within upstream areas 
to examine their potential effects on a target (e.g., stream network point or waterbody of interest). 
Often, practitioners use a "lumped" approach. 
For example, the proportion of area in a catchment occupied by urban land cover or 
the mean value for a landscape index (CITE PETERSON). In these cases, it is assumed 
that areas farther away from the target are equally influential to areas near the target. 

A more spatially explicit approach might be to generate buffers of successive distances 
away from the target and calculate the lumped statistics. For example, the proportion 
of area occupied by urban cover in a buffer of 250 m, 500 m, and 1000 m away from the target 
(CITE KIELSTRA AND KUGLEROVA). 

An even more spatially explicit approach is to calculate those statistics based 
on distances to the target, where areas closer to the target are expected to have 
more influence than areas further away (i.e., inverse distance-weighting). 
A set of inverse distance-weighted scenarios for stream survey sites was described 
in Peterson *et al.* (2011). Tools are implemented in ArcGIS (CITE PETERSON) as 
well as in R through GRASS GIS (CITE).  

**hydroweight** replicates this approach and provides a set of simple and 
flexible functions to accommodate a wider set of scenarios and statistics 
through WhiteboxTools (e.g., numeric rasters and categorical rasters). 
WhiteboxTools is ... . 
The advantages of hydroweight are being able to provide polygon layers with 
both categorical and numeric columns of interest, being able to provide numeric rasters, 
working within the set of WhiteboxTools, and the speed of WhiteboxTools. Here, 
we provide workflows for both stream networks and lakes. There are two functions: 

* *hydroweight()* generates distance-weighted rasters for targets
on a digital elevation model raster. Examples of targets include single points,
areas such as lakes, or linear features such as streams. The function outputs
a list of \code{length(weighting_scheme)} and an accompanying \code{*.rds} file
of distance-weighted rasters for targets (\code{target_O} is a point target as
in iFLO and \code{target_S} is a stream/waterbody target as in iFLS in
Peterson et al. 2011 <https://doi:10.1111/j.1365-2427.2010.02507.x>).
IMPORTANTLY, this function produces one instance of the weighting (i.e., one target and multiple weights).
Distance-weighted rasters, in turn, can be used in producing distance-weighted
attributes using \code{hydroweight::hydroweight_attributes()} (e.g., % urban
cover weighted by flow distance to a point). See examples and vignette for simple workflow.

* *hydroweight_attributes()* calculates distance-weighted attributes using distance-weighted rasters generated in *hydroweight()*, a region of interest
 (\code{roi}, e.g., a catchment polygon), and an attribute layer (\code{loi}, e.g., land use polygon/raster). The function outputs the attribute
 summary table or a list including the summary table and layers used for calculation. Summary statistics are calculated as in Peterson et al. 2011 <https://doi:10.1111/j.1365-2427.2010.02507.x>).
 IMPORTANTLY, this function only produces one instance of the layer x weight summary statistics (i.e., one \code{roi}, one \code{loi}, and one \code{distance_weight}).
 See example and vignette for simple workflow.

## 2.0 System setup 

## 3.0 Generate inverse distance-weighted rasters using hydroweight()

### 3.1 Generate toy dataset

Here, we demonstrate a simple workflow moving from a digital elevation model 
to distance-weighted rasters using a toy dataset. First, we generate ensure 
continuous flow using wbt::breach_depressions, calculate the flow accumulation 
in units of cells using the d-infinity algorithm, and extract cells that have 
at least accumulated 2000 cells as our streams.

```{r}

library(whitebox)
library(raster)
library(sf)
library(hydroweight)
library(sp)
library(rgeos)
library(dplyr)
library(foreach)

devtools::load_all()

## Import toy_dem from whitebox package
toy_file <- system.file("extdata", "DEM.tif", package="whitebox")
toy_dem <- raster::raster(toy_file)
raster::crs(toy_dem)<-CRS("+init=epsg:3161") # arbitrary

## Generate hydroweight_output dir
hydroweight_dir <- tempdir()

## Write toy_dem and run some processing through whitebox
raster::writeRaster(toy_dem,
                    file.path(hydroweight_dir, "toy_dem.tif"), overwrite = T)

wbt_breach_depressions(file.path(hydroweight_dir, "toy_dem.tif"),
                       file.path(hydroweight_dir, "toy_dem_breached.tif"))

wbt_d_inf_flow_accumulation(file.path(hydroweight_dir, "toy_dem_breached.tif"),
                            file.path(hydroweight_dir, "toy_dem_breached_accum.tif"),
                            out_type = "cells")

wbt_extract_streams(file.path(hydroweight_dir, "toy_dem_breached_accum.tif"),
                    file.path(hydroweight_dir, "toy_dem_streams.tif"),
                    threshold = 2000)

```

### 3.2 Construct targets

Next we construct our target. Here, we have just highlighted a low lying area 
in the landscape that we'll call a lake. Here, all cells below <220 m elevation 
are TRUE and all cells >220 m are assigned an NA. Then the raster of the positive
cells are converted to a polygon to represent the lake. 

Target streams are simply loaded up from the whitebox::wbt_extract_streams() output.

```{r, fig.width = 7, fig.height = 7}

## For hydroweight, there are target_O and target_S
## target_O is a target point or location for calculating distances
## target_S is a stream/waterbody target for calculating distances

## Generate target_0
tg_O <- toy_dem<220
tg_O[tg_O@data@values != 1] <- NA
tg_O <- raster::rasterToPolygons(tg_O, dissolve = TRUE)
tg_O <- sf::st_as_sf(tg_O)

## Generate target_S 
tg_S <- raster::raster(file.path(hydroweight_dir, "toy_dem_streams.tif"))

plot(toy_dem)
plot(tg_O, col="red", add = T)
plot(tg_S, col="blue", add = T)

```

### 3.3 Run hydroweight()

Now we run the hydroweight::hydroweight() function using our lake as a target 
for EucO, FLO, and HAFLO and streams as a target for EucS, FLS, and HAFLS. We 
decide that for EucS, FLS, and HAFLS that target_O will also be included as a 
"stream". We set a numeric value around target_O of 8000 m (i.e., the lake will 
be buffered by 8000 m and the whole region will be clipped by that value). Our
dem and flow_accum are assigned with character strings and our weighting schemes
are selected. We use the default weighting scheme. We also provide an example 
of how to calculate when we are only interested in the streams. We also provide 
an example of how to run over a sequence of sites. Here, we advocate the use 
of foreach() since we can allow skipping over errors.

```{r, fig.width = 7, fig.height = 7}
hydroweight_test <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O,
  target_S = tg_S,
  OS_combine = TRUE,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("EucO", "FLO", "HAFLO",
                       "EucS", "FLS", "HAFLS"),
  inv_function = function(x){ (x * 0.001 + 1)^-1 },
  uid = "1"
)

par(mfrow=c(2,3), mar=c(1,1,3,1))
plot(hydroweight_test[[1]], main=names(hydroweight_test)[1], axes=F, legend=F, col=viridis::viridis(10))
plot(hydroweight_test[[2]], main=names(hydroweight_test)[2], axes=F, legend=F, col=viridis::viridis(10))
plot(log(hydroweight_test[[3]]), main=names(hydroweight_test)[3], axes=F, legend=F, col=viridis::viridis(10))
plot(hydroweight_test[[4]], main=names(hydroweight_test)[4], axes=F, legend=F, col=viridis::viridis(10))
plot(hydroweight_test[[5]], main=names(hydroweight_test)[5], axes=F, legend=F, col=viridis::viridis(10))
plot(log(hydroweight_test[[6]]), main=names(hydroweight_test)[6], axes=F, legend=F, col=viridis::viridis(10))

```

Important things to note from this plot: 

* The region was clipped by an 8000 m buffer extended outward from the lake. 
* All values are scaled to 0-1 but HAFLO and HAFLS need to be log transformed and rescaled to help visualize the result.
* For FLO/HAFLO/FLS/HAFLS, only those cells contributing to the areas of interest are calculated. 
* As in Peterson, for HAFLO and HAFLS, the targets are set to NA

Now here are the temporary files that are made per instance of running hydroweight. 

```{r}

list.files(hydroweight_dir)[grep("TEMP-", list.files(hydroweight_dir))]

```

Now ignoring target_O or ignoring target_S:

```{r, fig.width = 7, fig.height = 7}
hydroweight_test_no_O <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_S = tg_S,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("EucS", "FLS", "HAFLS"),
  inv_function = function(x){ (x * 0.001 + 1)^-1 },
  uid = "1"
)

length(hydroweight_test_no_O)

hydroweight_test_no_S <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("EucO", "FLO", "HAFLO"),
  inv_function = function(x){ (x * 0.001 + 1)^-1 },
  uid = "1"
)

length(hydroweight_test_no_S)

```

### 3.4 Running hydroweight() across a sequence of sites

Here is an example of running hydroweight across a sequence of sites. I advocate
running foreach() since it can pass across any errors to be identified later and 
corrected without having to re-run everything. It also might allow for scalability 
when using doParallel (e.g., foreach(...) %dopar%) but I have not tested whitebox() 
in parallel (I suspect potentially big problems and a lot of burnt computers). 
Note that hydroweight() exports an .rds of the list it generates to hydroweight_dir meaning that you can assign 
the results of hydroweight() to an object or just run hydroweight() and upload 
the data afterwards.

```{r}

## Generate column for unique id, put 5 instances in a list, bind together, 
## and assign unique identifiers - these are our new "sites"
tg_O$id <- 1
tg_O_x5 <- list(tg_O, tg_O, tg_O, tg_O, tg_O)
tg_O_x5 <- do.call(dplyr::bind_rows, tg_O_x5)  
tg_O_x5$id <- seq(1:5)  

## Use foreach() but could use lapply() as well.
hydroweight_test_x5 <- foreach(x = 1:5, .errorhandling = "pass") %do% {
  
  message("Running hydroweight for site ", x, " at ", Sys.time())
  
  hydroweight_test <- hydroweight::hydroweight(
  hydroweight_dir = hydroweight_dir,
  target_O = tg_O_x5[x,],                      ### the important piece to change
  target_S = tg_S,
  OS_combine = TRUE,
  clip_region = 8000,
  dem = "toy_dem_breached.tif",
  dem_crs = crs(toy_dem),
  flow_accum = "toy_dem_breached_accum.tif",
  weighting_scheme = c("EucO", "FLO", "HAFLO",
                       "EucS", "FLS", "HAFLS"),
  inv_function = function(x){ (x * 0.001 + 1)^-1 },
  uid = tg_O_x5$id[x]                          ### the important piece to change
  )

  return(hydroweight_test)
}  
  
length(hydroweight_test_x5) # 5 sites 
length(hydroweight_test_x5[[1]]) # 6 distance-weighted rasters

## Loading up data after if didn't assign as an object while running
hydroweight_dir_files <- list.files(hydroweight_dir, full.names = TRUE)
hydroweight_test_x5 <- hydroweight_dir_files[grep("_hydrology.rds", hydroweight_dir_files)]
hydroweight_test_x5 <- lapply(hydroweight_test_x5, function(x) { readRDS(x) })

length(hydroweight_test_x5) # 5 sites
length(hydroweight_test_x5[[1]]) # 6 distance-weighted rasters

```
## 4.0 Generate inverse distance-weighted attributes using hydroweight_attributes()

### 4.1 Using a numeric raster layer of interest 


```{r, fig.width = 7, fig.height = 7}

## Construct toy catchment
tg_O_catchment <- sf::st_buffer(tg_O, dist = 2000, endCapStyle = "SQUARE")
hydroweight_extent <- sf::st_as_sfc(st_bbox(extent(hydroweight_test[[1]])))
sf::st_crs(hydroweight_extent) <- sf::st_crs(tg_O_catchment)

tg_O_catchment <- sf::st_intersection(tg_O_catchment, hydroweight_extent)

par(mfrow=c(1,1))
plot(hydroweight_test[[2]])
plot(tg_O_catchment, add=T)

## Construct continuous dataset
ndvi <- hydroweight_test[[1]]
ndvi@data@values <- runif(n = length(ndvi@data@values), min = 0, max = 1)
names(ndvi) <- "ndvi"

plot(ndvi)
plot(tg_O_catchment, add=T)

hydroweight_attribute_test_numeric <- lapply(hydroweight_test, function(hwr){

  test_numericraster <- hydroweight_attributes(roi = tg_O_catchment,
                                               loi = ndvi, 
                                               loi_numeric = TRUE, 
                                               distance_weight = hwr, 
                                               remove_region = tg_O, 
                                               resample = "bilinear", 
                                               return_products = TRUE, 
                                               uid = "1")
})

results <- lapply(hydroweight_attribute_test_numeric, function(x){x[[1]]})
results

par(mfrow=c(1,2))
plot(hydroweight_attribute_test_numeric[[1]][[2]])
plot(hydroweight_attribute_test_numeric[[1]][[3]])


```

### 4.2 Using a categorical raster layer of interest 

```{r}

hist(toy_dem)

lulc <- toy_dem
m <- c(0, 220, 1, 220, 300, 2, 300, 400, 3, 400, Inf, 4)
rclmat <- matrix(m, ncol = 3, byrow = TRUE)
lulc <- reclassify(lulc, rclmat)
plot(lulc)

hydroweight_attribute_test_categorical <- lapply(hydroweight_test, function(hwr){
  
  print(hwr)
  
  test_categoricalraster <- hydroweight_attributes(roi = tg_O_catchment,
                                               loi = lulc, 
                                               loi_numeric = FALSE, 
                                               distance_weight = hwr, 
                                               remove_region = tg_O, 
                                               resample = "ngb", 
                                               return_products = TRUE, 
                                               uid = "1", 
                                               )
})

results <- lapply(hydroweight_attribute_test_categorical, function(x){x[[1]]})
results

par(mfrow=c(1,3))
plot(lulc)
plot(tg_O_catchment, col = adjustcolor("blue", alpha.f = 0.5), add = T)
plot(hydroweight_attribute_test_categorical[[1]][[2]])
plot(hydroweight_attribute_test_categorical[[1]][[3]])

```

### 4.3 Using a polygon layer of interest with numeric data in the column 

### 4.4 Using a polygon layer of interest with categorical data in the column 

### 4.5 Running hydroweight_attributes() across a sequence of sites 

### 4.6 Running hydroweight_attributes() across a sequence of sites and layers of interest

## 5.0 References


## Construct a toy raster and polygon dataset 
lulc <- ndvi
lulc@data@values <- sample(c(1,2,3), size = length(lulc@data@values), replace = TRUE)
lulc_p <- raster::rasterToPolygons(lulc)

hist(lulc@data@values)
plot(lulc)
plot(lulc_p)

# ## 1) Construct a toy dataset ----
# 
# NC_lkscapes <- lkscape_ih[lkscape_ih_bsm]
# length(NC_lkscapes)
# 
# ## boundary 
# b <- st_union((NC_lkscapes[[2]][[3]]))
# b <- st_as_sf(b)
# plot(b)
# 
# ## land cover classes polygon
# lulc <- NC_lkscapes[[2]][[3]]
# lulc$ulc <- sample(c(100, 200, 300), size = 10, replace=T)
# lulc$grad_1 <- lulc$ulc 
# lulc$grad_2 <- lulc$ulc^2 * 0.75
# st_area(lulc)/st_area(b) # 74% and 0.008%
# 
# plot(b, col="lightgrey", border="lightgrey")
# plot(lulc["ulc"], add=T)
# plot(lulc["grad_1"], add=T)
# plot(lulc["grad_2"], add=T)
# 
# ## continuous
# ndvi <- dw
# (ndvi@data@values <- rnorm(n = length(ndvi@data@values), mean = 0, sd = 0.25))
# names(ndvi) <- "ndvi"
# 
# ## remove region (i.e., not included in calculation) 
# lake <- NC_lkscapes[[2]][[1]]
# plot(st_geometry(lake), add=T, col="lightblue")
# 
# ## distance_weight
# dw <- lkscape_ih_hydrology[[2]][[1]]
# 
# ## Real example, raster ---- 
# plot(ndvi)
# plot(b, add=T)
# 
# test_realraster <- hydroweight_attributes(boundary = b,
#                                           remove_region = lake,
#                                           distance_weight = dw,
#                                           layer = ndvi,
#                                           real = TRUE, 
#                                           resample = "bilinear", 
#                                           return_products = TRUE
# )
# test_realraster
# par(mfrow=c(1,3))
# plot(test_realraster[[2]], axes=F, legend=F, main = "data")
# plot(test_realraster[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(test_realraster[[2]] * test_realraster[[3]], main = "data * distance_weighting")
# 
# ## Real example, raster unweighted ----
# test_realraster_uw <- hydroweight_attributes(boundary = b,
#                                              remove_region = lake,
#                                              distance_weight = dw>0,
#                                              layer = ndvi,
#                                              real = TRUE, 
#                                              resample = "bilinear", 
#                                              return_products = TRUE
# )
# 
# viz <- test_realraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# 
# ## Categorical Example, raster weighted----
# lulc_rast <- fasterize::fasterize(lulc, raster = dw, 
#                                   field = "ulc")
# plot(lulc_rast)
# 
# test_categoricalraster <- hydroweight_attributes(boundary = b,
#                                                  remove_region = lake,
#                                                  distance_weight = dw,
#                                                  categories = NULL,
#                                                  layer = lulc_rast,
#                                                  real = FALSE, 
#                                                  resample = "ngb", 
#                                                  return_products = TRUE
# )
# 
# viz <- test_categoricalraster
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]])
# viz[[1]]
# 
# test_categoricalraster_uw <- hydroweight_attributes(boundary = b,
#                                                     remove_region = lake,
#                                                     distance_weight = dw>0,
#                                                     categories = NULL,
#                                                     layer = lulc_rast,
#                                                     real = FALSE, 
#                                                     resample = "ngb", 
#                                                     return_products = TRUE
# )
# 
# viz <- test_categoricalraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]]) # should be summing to 1
# viz[[1]]
# 
# ## Real example, from polygon column ----
# 
# test_realpolygon <- hydroweight_attributes(boundary = b,
#                                            remove_region = lake,
#                                            distance_weight = dw,
#                                            categories = c("grad_1", "grad_2"),
#                                            layer = lulc,
#                                            real = TRUE, 
#                                            resample = "ngb", 
#                                            return_products = TRUE
# )
# 
# viz <- test_realpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_realpolygon_uw <- hydroweight_attributes(boundary = b,
#                                               remove_region = lake,
#                                               distance_weight = dw>0,
#                                               categories = c("grad_1", "grad_2"),
#                                               layer = lulc,
#                                               real = TRUE, 
#                                               resample = "ngb", 
#                                               return_products = TRUE
# )
# 
# viz <- test_realpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## Categorical example, from polygon column ----
# 
# test_categoricalpolygon <- hydroweight_attributes(boundary = b,
#                                                   remove_region = lake,
#                                                   distance_weight = dw,
#                                                   categories = c("grad_1", "grad_2"),
#                                                   layer = lulc,
#                                                   real = FALSE, 
#                                                   resample = "bilinear", 
#                                                   return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_categoricalpolygon_uw <- hydroweight_attributes(boundary = b,
#                                                      remove_region = lake,
#                                                      distance_weight = dw>0,
#                                                      categories = c("grad_1", "grad_2"),
#                                                      layer = lulc,
#                                                      real = FALSE, 
#                                                      resample = "bilinear", 
#                                                      return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 



```




# ## ***********************
# ## TEST - HYDROWEIGHT ----
# ## *********************** 
# 
 
# ## Write toy_dem and run some processing through whitebox
# raster::writeRaster(toy_dem, 
#                     file.path(hydroweight_dir, "toy_dem.tif"), overwrite = T)
# 
# wbt_breach_depressions(file.path(hydroweight_dir, "toy_dem.tif"), 
#                        file.path(hydroweight_dir, "toy_dem_breached.tif"))
# 
# wbt_d_inf_flow_accumulation(file.path(hydroweight_dir, "toy_dem_breached.tif"), 
#                             file.path(hydroweight_dir, "toy_dem_breached_accum.tif"), 
#                             out_type = "cells")
# 
# wbt_extract_streams(file.path(hydroweight_dir, "toy_dem_breached_accum.tif"), 
#                     file.path(hydroweight_dir, "toy_dem_streams.tif"),
#                     threshold = 2000)
# 
# ## For hydroweight, there are target_O and target_S 
# ## target_O is a target point or location for calculating distances 
# ## target_S is a stream/waterbody target for calculating distances 
# 
# ## Generate target_0
# tg <- toy_dem<220
# tg[tg@data@values != 1] <- NA
# tg <- raster::rasterToPolygons(tg, dissolve=T)
# tg <- sf::st_as_sf(tg)
# 
# plot(toy_dem)
# plot(tg, col="red", add=T)
# plot(streams, col="blue", add=T)
# 
# hydroweight_test <- hydroweight(
#   hydroweight_dir = "./out_spatial/hydroweight_output", 
#   target_O = tg, 
#   target_S = "toy_dem_streams.tif", 
#   target_OS = TRUE,
#   clip_region = 8000,
#   dem = "toy_dem_breached.tif", 
#   flow_accum = "toy_dem_breached_accum.tif", 
#   weighting_scheme = c("iEucO", "iFLO", "HAiFLO", 
#                        "iEucS", "iFLS", "HAiFLS"), 
#   inv_function = function(x){ (x * 0.001 + 1)^-1 },
#   uid = "1"
# )
# 
# par(mfrow=c(2,3), mar=c(1,1,3,1))
# plot(hydroweight_test[[1]], main=names(hydroweight_test)[1], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[2]], main=names(hydroweight_test)[2], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[3]], main=names(hydroweight_test)[3], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[4]], main=names(hydroweight_test)[4], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[5]], main=names(hydroweight_test)[5], axes=F, legend=F, col=viridis::viridis(10))
# plot(hydroweight_test[[6]], main=names(hydroweight_test)[6], axes=F, legend=F, col=viridis::viridis(10))

# ## **********************************
# ## TEST - HYDROWEIGHT_ATTRIBUTES ----
# ## ********************************** 
# 
# ## Construct toy watershed
# tg_shed <- st_buffer(tg, dist = 1000, endCapStyle = "SQUARE")
# hydroweight_extent <- st_as_sfc(st_bbox(extent(hydroweight_test[[1]])))
# st_crs(hydroweight_extent) <- st_crs(tg_shed)
# 
# tg_shed <- st_intersection(tg_shed, hydroweight_extent )
# 
# par(mfrow=c(1,1,))
# plot(hydroweight_test[[2]])
# plot(tg_shed, add=T)
# 
# ## Real example, raster ---- 
# 
# ## Construct continuous dataset 
# ndvi <- hydroweight_test[[1]]
# (ndvi@data@values <- runif(n = length(ndvi@data@values), min = 0, max = 1))
# 
# plot(ndvi)
# plot(tg_shed, add=T)
# 
# hydroweight_attribute_test_real <- lapply(hydroweight_test, function(hwr){
#   
#   test_realraster <- hydroweight_attributes(boundary = tg_shed,
#                                             remove_region = tg,
#                                             distance_weight = hwr,
#                                             layer = ndvi,
#                                             real = TRUE, 
#                                             resample = "bilinear", 
#                                             return_products = TRUE
#   )
#   
# })
# 
# results <- lapply(hydroweight_attribute_test_real, function(x){x[[1]]})
# results
# 
# 
# 
# ## 1) Construct a toy dataset ----
# 
# NC_lkscapes <- lkscape_ih[lkscape_ih_bsm]
# length(NC_lkscapes)
# 
# ## boundary 
# b <- st_union((NC_lkscapes[[2]][[3]]))
# b <- st_as_sf(b)
# plot(b)
# 
# ## land cover classes polygon
# lulc <- NC_lkscapes[[2]][[3]]
# lulc$ulc <- sample(c(100, 200, 300), size = 10, replace=T)
# lulc$grad_1 <- lulc$ulc 
# lulc$grad_2 <- lulc$ulc^2 * 0.75
# st_area(lulc)/st_area(b) # 74% and 0.008%
# 
# plot(b, col="lightgrey", border="lightgrey")
# plot(lulc["ulc"], add=T)
# plot(lulc["grad_1"], add=T)
# plot(lulc["grad_2"], add=T)
# 
# ## continuous
# ndvi <- dw
# (ndvi@data@values <- rnorm(n = length(ndvi@data@values), mean = 0, sd = 0.25))
# names(ndvi) <- "ndvi"
# 
# ## remove region (i.e., not included in calculation) 
# lake <- NC_lkscapes[[2]][[1]]
# plot(st_geometry(lake), add=T, col="lightblue")
# 
# ## distance_weight
# dw <- lkscape_ih_hydrology[[2]][[1]]
# 
# ## Real example, raster ---- 
# plot(ndvi)
# plot(b, add=T)
# 
# test_realraster <- hydroweight_attributes(boundary = b,
#                                           remove_region = lake,
#                                           distance_weight = dw,
#                                           layer = ndvi,
#                                           real = TRUE, 
#                                           resample = "bilinear", 
#                                           return_products = TRUE
# )
# test_realraster
# par(mfrow=c(1,3))
# plot(test_realraster[[2]], axes=F, legend=F, main = "data")
# plot(test_realraster[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(test_realraster[[2]] * test_realraster[[3]], main = "data * distance_weighting")
# 
# ## Real example, raster unweighted ----
# test_realraster_uw <- hydroweight_attributes(boundary = b,
#                                              remove_region = lake,
#                                              distance_weight = dw>0,
#                                              layer = ndvi,
#                                              real = TRUE, 
#                                              resample = "bilinear", 
#                                              return_products = TRUE
# )
# 
# viz <- test_realraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# 
# ## Categorical Example, raster weighted----
# lulc_rast <- fasterize::fasterize(lulc, raster = dw, 
#                                   field = "ulc")
# plot(lulc_rast)
# 
# test_categoricalraster <- hydroweight_attributes(boundary = b,
#                                                  remove_region = lake,
#                                                  distance_weight = dw,
#                                                  categories = NULL,
#                                                  layer = lulc_rast,
#                                                  real = FALSE, 
#                                                  resample = "ngb", 
#                                                  return_products = TRUE
# )
# 
# viz <- test_categoricalraster
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]])
# viz[[1]]
# 
# test_categoricalraster_uw <- hydroweight_attributes(boundary = b,
#                                                     remove_region = lake,
#                                                     distance_weight = dw>0,
#                                                     categories = NULL,
#                                                     layer = lulc_rast,
#                                                     real = FALSE, 
#                                                     resample = "ngb", 
#                                                     return_products = TRUE
# )
# 
# viz <- test_categoricalraster_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# sum(viz[[1]]) # should be summing to 1
# viz[[1]]
# 
# ## Real example, from polygon column ----
# 
# test_realpolygon <- hydroweight_attributes(boundary = b,
#                                            remove_region = lake,
#                                            distance_weight = dw,
#                                            categories = c("grad_1", "grad_2"),
#                                            layer = lulc,
#                                            real = TRUE, 
#                                            resample = "ngb", 
#                                            return_products = TRUE
# )
# 
# viz <- test_realpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_realpolygon_uw <- hydroweight_attributes(boundary = b,
#                                               remove_region = lake,
#                                               distance_weight = dw>0,
#                                               categories = c("grad_1", "grad_2"),
#                                               layer = lulc,
#                                               real = TRUE, 
#                                               resample = "ngb", 
#                                               return_products = TRUE
# )
# 
# viz <- test_realpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## Categorical example, from polygon column ----
# 
# test_categoricalpolygon <- hydroweight_attributes(boundary = b,
#                                                   remove_region = lake,
#                                                   distance_weight = dw,
#                                                   categories = c("grad_1", "grad_2"),
#                                                   layer = lulc,
#                                                   real = FALSE, 
#                                                   resample = "bilinear", 
#                                                   return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# test_categoricalpolygon_uw <- hydroweight_attributes(boundary = b,
#                                                      remove_region = lake,
#                                                      distance_weight = dw>0,
#                                                      categories = c("grad_1", "grad_2"),
#                                                      layer = lulc,
#                                                      real = FALSE, 
#                                                      resample = "bilinear", 
#                                                      return_products = TRUE
# )
# 
# viz <- test_categoricalpolygon_uw
# par(mfrow=c(1,3))
# plot(viz[[2]], axes=F, legend=F, main = "data")
# plot(viz[[3]], axes=F, legend=F, main = "distance_weighting")
# plot(viz[[2]] * viz[[3]], main = "data * distance_weighting")
# viz[[1]]
# 
# ## ALL WORKS - OBVIOUSLY NEED BETTER EXAMPLES

# ## **********
## PLOTS ----
## ********** 

# ## 1) Distance weighted catchment influence ---- 
# 
# rescale_r <- function(x, x_min =NULL, x_max = NULL, new_min = 0, new_max = 1) {
#   if(is.null(x_min)) x_min = cellStats(x, min)
#   if(is.null(x_max)) x_max = cellStats(x, max)
#   new_min + (x - x_min) * ((new_max - new_min) / (x_max - x_min))
# }
# 
# ## Rasters to plot after running one instance of the loop
# iEucO_p <- hydroweight_attribute_test_real[[1]][[2]] * hydroweight_attribute_test_real[[1]][[3]]
# iFLO_p <- hydroweight_attribute_test_real[[2]][[2]] * hydroweight_attribute_test_real[[2]][[3]]
# HAiFLO_p <- hydroweight_attribute_test_real[[3]][[2]] * hydroweight_attribute_test_real[[3]][[3]]
# HAiFLO_p <- rescale_r(log(HAiFLO_p+1), new_min = 0, new_max = 1)
# iEucS_p <- hydroweight_attribute_test_real[[4]][[2]] * hydroweight_attribute_test_real[[4]][[3]]
# iFLS_p <- hydroweight_attribute_test_real[[5]][[2]] * hydroweight_attribute_test_real[[5]][[3]]
# HAiFLS_p <- hydroweight_attribute_test_real[[6]][[2]] * hydroweight_attribute_test_real[[6]][[3]]
# HAiFLS_p <- rescale_r(log(HAiFLS_p+1), new_min = 0, new_max = 1)
# 
# tiff(filename=paste0("./out_figs/", "Merc_DistanceWeightedCatchmentInfluence",
#                      Sys.Date(), ".tif"),
#      width=15, height=10, units="cm", res=300,
#      compression="lzw+p", type="cairo")
# 
# par(mfrow=c(2,3), oma=c(0,0,0,0), mar=c(0,0,2,0))
# plot(iEucO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iEucO")
# plot(tg_shed, add=T, col=NA, border="black")
# 
# plot(iFLO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iFLO")
# 
# plot(HAiFLO_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "HA-iFLO")
# 
# plot(iEucS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iEucS")
# 
# plot(iFLS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "iFLS")
# 
# plot(HAiFLS_p, zlim=c(0,1), breaks = seq(0,1, by=0.01), col=rev(viridis(101)), 
#      legend = FALSE, axes=FALSE, box=FALSE, main = "HA-iFLS")
# 
# dev.off()
# 
# hydroweight_attribute_test_real[[1]][[1]]


















